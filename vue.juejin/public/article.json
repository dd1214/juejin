[
    {   "snapshot": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/897ed2f96d5b4144bdeeab68e65c9690~tplv-k3u1fbpfcp-watermark.image?",
        "title": "人生中的第一次被辞退",
        "preview": "2022年8月26日下午5点半得到的通知，有10天的缓冲但没有补偿，理由是没有没有过试用期，离试用期还有10天。 一、咋进的公司？ 公司与甲方签的一个单子快到时间了公司没人写，没怎么面试问了我以前写的",
        "author": "vue工程师",
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/0f831df7178b3c0b35cf9e8fd3c372c1~300x300.image",
        "content": "2022年8月26日下午5点半得到的通知，有10天的缓冲但没有补偿，理由是没有没有过试用期，离试用期还有10天。<br>\r\n一、咋进的公司？<br>\r\n公司与甲方签的一个单子快到时间了公司没人写，没怎么面试问了我以前写的项目就让我通过了，工资是不打折的。<br>\r\n二、进公司干了啥？<br>\r\n目前是80天，30天开发后台管理（81张设计稿，60个接口,vue写的），10天修改后台管理第二版，后面40天就是噩梦了，维护前后端不分离的和前后端分离的jq。(时间只是大概，具体不记得了)<br>\r\n\r\n三、辞退原因<br>\r\n公司给的原因：维护开发效率太低。<br>\r\n个人认为的原因：\r\n<br>1、之前没接触jq（进来前没说用jq和要维护前后端不分离的项目）。之前那哥们是一毕业就在这家公司写了两年半jq工资没加第二年还降了，与之相比我这之前没接触jq项目的，我维护的效率比他低（是从领导嘴里说的，末尾还加句不要觉得我在pua你）。<br>\r\n2、状态不好。我加了上个前端的微信，他当时走了2个月但他现在还没找到工作在家学习vue，我离职了他都没找到工作，这jq我越写越焦虑，我怕有一天忘记vue、react、uniapp就只会jq，简历上全是jq项目我下份工作怎么找。在这种焦虑中工作不在状态想离职但又怕找不到工作，有点摆烂（这里指我正常工作正常下班）。<br>\r\n四、感受<br>\r\n1、失落。居然被这样一份工作辞退，开始怀疑自己能不能干这行业，自己怕不是个垃圾(虽然确实是菜狗...)。<br>\r\n2、担忧。目前了解到的找工作的前端，一个找了5个月在家学vue的（这公司上个前端），一个找了6个月的，一个找了2个月但找了比较好的工作，我丫的不会也找几个月吧（看来要练习一下捡瓶子，防止饿死）。<br>\r\n3、解脱、丫的，终于10天后不用维护这些垃圾代码了brief，焯！！！爽！！！<br>\r\n五、有什么打算？<br>\r\n1、先到杭州见一下老朋友，当然也可能约不出来（尴尬），顺便去面试。<br>\r\n2、回老家一趟，两年没回去想家了。<br>\r\n3、去深圳<del>那个唯一叫我靓仔的地方</del>，之后可能就饿死在那。<br>\r\n六、后续<br>\r\n1、**上一个前端**：找到了一个外派的工作，但工资有点低，2年半经验8.5k,还是找了半年的结果（微信跟我说的）<br>\r\n2、**接替我工作的前端**：干了一个月离职了，“这年头谁还手搓js啊”（这是原话）,她更狠不知道她是不是后面直接没用jq了...<br>\r\n3、**我**：目前在一个18人的研发团队里做前端（目前还在扩招），工资不错，一天6个半小时工作时间没加过班不打卡（来这25天没加过一分钟班），公司很大有自己的食堂，项目都是新的自己选择框架和技术，自己格外珍惜这份工作，希望后面能转正（如来佛祖，太上老君，耶稣...都来保佑我转正，哈哈哈）。<br>\r\n4、**上一家公司**：感觉上家公司的那个领导（是个后端不懂前端）挺缺德的，我都明确问了要什么框架，说是随便用，**接替我工作的前端**她也被蒙在鼓里。那个领导直接说明，估计90%的前端不会来，前后端不分离的项目，工资还低。\r\n\r\n"
    },
    {   "snapshot": "",
        "title": "JetBrains再出手，这次要干翻 VS Code了？？？？",
        "preview": "这几天，JetBrains Fleet 可以说是闹的沸沸扬扬，官方的态度很明确，我们是下一代 IDE，使用了 IntelliJ 代码处理引擎，并且是建立在 20 年的 IDE 开发经验的基础之上。 听",
        "author": "沉默王二",
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/b6bfc3ccd6d610412b216b9c346ef533~300x300.image",
        "content": "\r\n\r\n\r\n这几天，JetBrains Fleet 可以说是闹的沸沸扬扬，官方的态度很明确，我们是下一代 IDE，使用了 IntelliJ 代码处理引擎，并且是建立在 20 年的 IDE 开发经验的基础之上。\r\n\r\n>Built from scratch, based on 20 years of experience developing IDEs. JetBrains Fleet uses the IntelliJ code-processing engine, with a distributed IDE architecture and a reimagined UI.\r\n\r\n听起来口气就很大，网上也是铺天盖地吹。今天我也来体验一把，看看这玩意到底能不能干掉 VScode，毕竟微软的 VScode 在轻量级这方面就是妥妥的标杆，Fleet 到底牛不牛逼，肯定是要以 VScode 作为参照的，对吧？\r\n\r\n## 下载安装Fleet\r\n\r\n直接搜 JetBrains 关键字，就可以看到 Fleet 的搜索结果。\r\n\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8cc8bd50d369411bb369bf810453fd03~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n直接戳过去就可以看到下载的按钮了，（注意，目前是公测版）。\r\n\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d65a002ee5c0467792c0d490a20f990d~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n接下来，映入眼帘的就应该是 Fleet 的代码编辑页面了。说实话，光看这张宣传图，确实挺惊艳的。\r\n\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b0632451da14d1cabffb1866dadb2e9~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n接着进入 download 页面，可以看到安装 Fleet 需要提前先安装 Toolbox App，\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a6a81159381f4845a52274a35b349de5~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n没啥好说的，直接下载安装就 OK 了。接着启动 Toolbox，就可以看到 Fleet 了。说实话，这个 Toolbox 感觉还真的挺不错的，里面把我之前安装的 Intellij IDEA 社区版和旗舰版都显示出来了，并且提示我要更新（可我是有私心的，旗舰版肯定是不会更新的😂）。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/38ce58d0662a48b78b01f518e199372e~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n直接点击安装，就可以看到 Fleet 的安装进度条了（下载速度并不算快🤮）。\r\n\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d33ad8785864b7d93a02f54b83da838~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n稍等片刻。等安装完成后，点一下就可以启动 Fleet 了。第一次启动后的界面如下所示。\r\n\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a74b5320d5494ccca0cb329198c43eec~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n挺人性化的，提供了 Git、SSH、Docer 等链接方式。但不得不吐槽的事，Git 的方式还不够流畅，需要先去 generate 一个 token 才行。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/718b7bdeb8f44497af91914d8fe2ef4c~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n与其这样，不如直接使用 GitHub 桌面版把代码导入到本地，然后再直接打开本地代码库（😂）。\r\n\r\nOK，打开一个我们四剑客团队正在研发的一个新项目。整个打开的过程还是非常快的，比起 Intellij IDEA，确实要快很多很多很多很多。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fbd38c2488c4449287b862a07ce48447~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n\r\n\r\n## 智能化模式\r\n\r\n紧接着，Fleet 会提示我们开启智能化代码分析，OK，开启它。\r\n\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4b573c2555564e919b8477967642dcc6~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n开启的过程会去加载蛮多东西的，比如说 JDK、Maven 等等，需要比较久的时间。这一点还是非常牛逼的，要换成是 Intellij IDEA 的话，在正式开发之前，必须得自己先配置好 JDK、Maven，对吧？\r\n\r\n这下可好，Fleet 直接帮我们搞定了。\r\n\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d9c73b02d2c94be7b2d0bacbae0fa2d0~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n加载完成后，代码的高亮颜色也会发生一些改变，更加丰富了。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7628ee3e610a452182e05bd64ab2fc05~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n开启智能化模式后，Fleet 就具备了**智能补全、重构、导航、调试、实时代码质量检查、快速修复**的所有功能，如果只是普通的文本编辑，则可以一键关闭智能化模式。\r\n\r\nOK，我们找到主类，然后运行看一下效果。（第一次竟然要下载 kotlin、jps standalone 等等玩意，还失败了😂，不过第二次重新运行就 OK 了）\r\n\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ceafe8e00a2a46858ca05d271c7aec06~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n当然了，如果你没有启动智能化模式，只需要轻点右上角的「闪电」小图标就 OK 了。否则，主类会没有可运行按钮。\r\n\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/478498306ea640e28a62116e475474a5~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n\r\n## 搜索与导航\r\n\r\nFleet 提供了多种搜索和导航工作区的方法，允许我们快速查找文件、文件中的位置等等。只需要点击右上角的搜索🔍图标就可以打开了。\r\n\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/74c73ec1415b44e58788567d7125fa33~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n如果不清楚该干嘛，还可以切换到 action 面板，实现快速操作，比如说后退到上一步。\r\n\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b1d18fba87b47089f646db3154ee4fc~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n\r\n\r\n\r\n## 轻量级😂\r\n\r\nFleet 主打的是轻量级，对标的是 VS Code，那此时此刻，肯定有不少小伙伴很关心 Fleet 到底占用了多少内存。\r\n\r\nOK，刚好我电脑上也启动了 Intellij IDEA 旗舰版、VS Code，我们就来看一下，内存占用。\r\n\r\nIDEA 差不多 2 G，Fleet 是只占了 877M，但还有一个 fleet_backend 的进程占用了 1.95G，这样算下来，比 Intellij IDEA 还“重”啊！！！！！！！\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6f494a28b620433684efd8a3660f17ef~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n再往下找一下 VS Code，好家伙，100M 不到。\r\n\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6d82845ec4734ad88ea80b19fb88ffb1~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n这。。。。。\r\n\r\n看到这么可怕的内存占用，估计会劝退不少小伙伴。但毕竟 Fleet 只是公测，还是要相信 JetBrains 的实力，它们应该不会忽视这样的问题。\r\n\r\n不过，虽然比较吃内存，但启动快到是真的挺快的。\r\n\r\n## 多语言支持\r\n\r\nFleet 既然对标的是 VS Code，那么多语言肯定也是要支持的呀。所以像 Python、Java、JavaScript、Go 等等这些常见的编程语言。\r\n\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ebf784e75373409698824aa4f1bb1ec2~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n我体验了一下 JavaScript，支持得还是挺丝滑的，语法提示、语法高亮，都做的挺到位的。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/69fb6a1cba43486dac60018769d5f180~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n当然了，就目前的版本而言，Java、Kotlin、JavaScript、Python 等语言支持得比较友好（语法高亮、自动缩进、大括号匹配、自动导入包、智能空格、代码补全、类型定义、格式化、语法提示、错误警告⚠️、快速修复等等），CPP 这块还有待开发。\r\n\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/79584e3a83bf44199d36accff83dc27c~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n对于 Java 开发者来说，Fleet 支持得还是非常值得投入感情的，Intellij IDEA 拥有的功能 Fleet 也都拥有了，就连 yaml 也能很好的支持。\r\n\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/70aded8219254714a8f4dff5eadfb7aa~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\ndebug 模式的调试也非常舒服，快捷键和 Intellij IDEA 也一样。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/28eea26c41eb42f6a0b1341f683ede4d~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n\r\n## 版本控制\r\n\r\nFleet 对版本控制的集成也更加方便，直接在左侧就有一个 Git 的 tab，进入该 tab，然后选择要提交的文件，填入 commit 的信息，就可以提交了。\r\n\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb19d85971df4262963eb0a5bb540f94~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n感觉比 Intellij IDEA 便捷，有没有？点击「history」面板还可以查看版本历史。\r\n\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/39b5c08be4d84e3992b2da4ca09888eb~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n\r\n## 云开发\r\n\r\nFleet 旨在打造轻量级、云协作开发，那云开发这块也是蛮重要的。Fleet 提供了多种方式，云空间、SSH、甚至 Docker。\r\n\r\nJetBrains 提供了免费的空间使用，我这里申请了一个，我们来体验一下。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f6d09fe4d2614d14851e03939c778382~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n在 space 选项中填入空间的 URL，之后填写邮箱名和密码就可以登录空间工作站了。\r\n\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7f4ddd9260db4b9d904424146c3ad20c~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n有点遗憾的是，空间站版本和 Fleet 版本不兼容，暂时打不开。\r\n\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b436485d3a244a89896868499064bc0f~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n除了空间站，还可以在远程主机上安装 JetBrains Fleet，然后利用远程主机作为实际的工作空间，然后用 Fleet 作为客户端进行连接。不过也很遗憾，我这边一直初始化失败。\r\n\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8a50a9e55e8a47a599e4ce79381b921e~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n等 Fleet 推出正式版再尝试吧（😭）。\r\n\r\n## 多人协作\r\n\r\n无论是本地还是远程，都可以轻松进行多人项目协作。只不过，和idea code with me 插件一样，也就懒得演示了，直接看官方给的 GIF 吧。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/206dc1aaa10d4902a1b4b8073f79175e~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n## 设置\r\n\r\nFleet 的设置确实更加便捷一些，直接点击右上角的设置按钮就可以进入设置页面，尤其是修改主题时还有“所见即所得”的效果，选择一个主题就直接看到效果了，非常不错。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b3ff71f79f0d461e8c7d2b15f12c6e77~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n## ending\r\n\r\n整体体验下来，可以明显地感受出来，Fleet 这个公测版还有很多需要加强的地方，尤其是内存占用和云协作这块。除此之外，Fleet 作为一个轻量级的 IDE 还是够用了，尤其是对 Java 的编程支持的非常 nice。\r\n\r\n如果只是简单的增删改查，包括 debug，基本上是可以替代 Intellij IDEA 了。\r\n\r\n但 Fleet 这款产品的定位肯定不是取代自家产品 Intellij IDEA 的，而是对标微软的 VS Code，就我个人的使用体验来看，内存占用这块差距甚远，只有在 Java 这块感觉确实是有 20 多年 IDE 的开发经验，确实不错。\r\n\r\n总之，JetBrains 的产品值得期待。反正多一个顺手的免费工具，我是不介意的，😆\r\n\r\n没有什么使我停留——除了目的，纵然岸旁有玫瑰、有绿荫、有宁静的港湾，我是不系之舟。\r\n\r\n**本文已收录到 GitHub 上星标 3.6k+ 的开源专栏《Java 程序员进阶之路》，据说每一个优秀的 Java 程序员都喜欢她，风趣幽默、通俗易懂。内容包括 Java 基础、Java 并发编程、Java 虚拟机、Java 企业级开发（Git、Nginx、Maven、Intellij IDEA、Spring、Spring Boot、Redis、MySql 等等）、Java 面试等核心知识点。学 Java，就认准 Java 程序员进阶之路**😄。\r\n\r\nGithub 仓库：[https://github.com/itwanger/toBeBetterJavaer](https://github.com/itwanger/toBeBetterJavaer)\r\n\r\n\r\n\r\nstar 了这个仓库就等于你拥有了成为了一名优秀 Java 工程师的潜力。\r\n\r\n\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/747fbe99ff7840ecb9026c97543f2462~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n\r\n\r\n\r\n"
    },
    {   "snapshot": "",
        "title": "一个30+大龄前端的2022年中总结（还贷，还情，还我金铲铲）",
        "preview": "作为一名30多岁的前端，并且只会前端的我来说，2022要总结的东西有很多，但总结起来其实就是一句话：工资不见往上涨，我还不敢往外闯",
        "author": "末世未然",
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/f0468eddaf02ec1ab8284257e0e5880d~300x300.image",
        "content": "---\r\ntheme: cyanosis\r\nhighlight: atom-one-dark\r\n---\r\n「时光不负，创作不停，本文正在参加[2022年中总结征文大赛](https://juejin.cn/post/7108989863126368286 \\\"https://juejin.cn/post/7108989863126368286\\\")」\r\n\r\n作为一名30多岁的前端，并且只会前端的我来说，2022要总结的东西有很多，但总结起来其实就是一句话：工资不见往上涨，我还不敢往外闯。\r\n\r\n# 房贷下来了\r\n 去年1月份，我跟老婆商量着在市区买套房，但是看了看自己的腰包，以及首付4成需要准备太多钱了，咱们就放弃了，打算去郊区看看，没办法，实力不允许，只能退而求其次。于是几个周末都在了解各个楼盘，看了3个盘吧，咱们最后选择了第一个盘，并在去年6月签了购房合同。首付透支了我们的全部积蓄，还借了10w。我跟老婆工资都不高，但是在之后的半年里，竟然积攒了10w，是我们没有想到的，说是省吃俭用吧，也没有那么夸张，但是就比平时多攒了钱。做做兼职，写写页面，小的活500-1000，大点的3000-5000。那段时间确实攒了一些钱。\r\n \r\n 今年房贷下来了，每月交6000。对于我们这种普通家庭的人来说，压力是相当大的。但30多岁了，老婆怀孕快生了，每天还得做饭洗衣拖地，兼职的活也不敢接太难的，当然太难的我也不会...\r\n \r\n# 老婆快生了\r\n老婆怀孕期间，说实话，是欠了一些陪伴的，虽说每天都在一起，但是为了多攒一些钱，晚上吃完饭刷完碗我就栽进书房写代码了。周末偶尔出门在附近逛逛，也仅限于附近。最让我后悔的还是没带老婆去拍孕妇照，虽说她嘴上说不要，我应该硬拗她去的。只有少量视频与照片存在手机里，但这些和艺术照还是有相当大的差距的，在坐的大老爷们以后另一半说不要的时候，你也得去，这是一种仪式感。\r\n\r\n老婆生之前，每晚睡前会给宝宝做胎教，买了2本故事书，来来回回念，心想宝宝也许还能想起来这个故事好像听过，增加Ta的记忆力（好吧，单纯就是为了省点钱 捂脸ing）\r\n\r\n孕期千万不要让老婆干家务，提重物！孕期千万不要让老婆干家务，提重物！孕期千万不要让老婆干家务，提重物！别说孕期，平时家务这种事，作为大老爷们也应该承包了，研究表明，家庭中男性做家务幸福指数更高。\r\n# 孩子出生了\r\n在五月的某个周一早上5点多，老婆羊水破了要生了，我真的紧张了，紧张到拨打120都按错号码，按对后对方问我地址，我大脑都空白了几秒，后面才想起来在哪。孩子也真会挑时候，选择在周一早上我还没去上班的时候发动。\r\n\r\n老婆去医院待产这件事，我要跟大家分享下经验\r\n1. 在老婆预产期前一周最好把核酸做了，以免因为核酸没过被卡在外面。\r\n2. 提前一个月把待产包准备好（我们是准备了一个大行李箱，里面装宝宝出生后用的衣物用品奶粉还有妈妈的东西也要准备好，具体可以在抖音搜索`待产包`），宝宝发动直接拎包去医院。\r\n3. 如果需要打无痛分娩的，打之前不能进食。\r\n4. 进产房跟老婆在一起，这种钱不能省。\r\n\r\n我老婆是顺产不出转剖宫产的，很多人会说直接选择剖，我在老婆顺不出来的时候也后悔没有直接剖，但是这边顺还是剖，最好还是听从医嘱，毕竟剖宫也是存在风险的，医生也不敢打包票。所以能顺还是尽量顺，这样身体也恢复的更快。\r\n\r\n老婆从产房出来，生了个女宝宝，母女平安，我当爸爸了！都说女儿是爸爸前世的情人，这份情我要还\r\n## 疫情下的90后父母\r\n由于疫情期间医院只允许一个人陪护，所以在接下来的5天时间里，宝宝的吃喝拉撒，老婆的饮食与护理，全落在我身上。也是这几天，让我从一个无知小子变身一个超级奶爸：喂奶，抱娃，换尿不湿，哄睡等等。虽说一个人确实辛苦，但回想起来，那几天却是幸福的回忆。\r\n# 我却躺平了\r\n整个上半年其实重心主要还是在家庭，工作上确实有点摸鱼了。\r\n\r\n## 一次创意大赛让我重回掘金\r\n\r\n早在2017年我就加入了掘金，但是直到2021年才在掘金写了第一篇文章，也没来由，就瞎写，啥活动也不知道，签到也不懂。直到今年4月份，在一次偶然的机会，遇到[大帅](https://juejin.cn/user/2955079655898093)，他发起了一次掘金创意大赛组队参赛的邀请，我抱着试试看的态度报名了。并在之后疯狂参加掘金活动（羊毛撸起来）。在掘金，目前已收集奖品如下：\r\n- [x] 小黄鸭\r\n- [x] 马克杯\r\n- [x] 空调毯\r\n- [x] 太空人风扇\r\n- [x] 拖鞋\r\n- [x] 榨汁机\r\n- [x] 电饭煲\r\n- [x] 小爱音箱\r\n\r\n获奖文章链接：\r\n\r\n[从零开始做一个贪吃蛇游戏，会vue就行](https://juejin.cn/editor/drafts/7085285244743450638)\r\n\r\n[我用一个div就画出了一个大西瓜~](https://juejin.cn/post/7109729038981136391)\r\n\r\n## 背单词\r\n曾几何时大学不需要过英语4级就能毕业的时候，在裸考参加了4次4级考试，一次比一次考得低的时候，果断就放弃了，反正不影响毕业~\r\n\r\n现在后悔啊，英语真的很重要，不会英语或者英语不好做程序员是非常吃亏的，且不说看英文文档了，就写代码命个名都得百度翻译一下，无形中效率变低。\r\n\r\n推荐大家一款背单词的app：墨墨背单词。\r\n我坚持打卡666天，从刚开始每天50个到每天30个到现在每天10个单词。因为太多了真的坚持不下来，`如果你发现自己坚持不下来一件事的时候，一定要降低点标准`，毕竟每天走一步总比不走强。背10个单词花不了你3分钟。这就是我坚持打卡了快2年的原因。\r\n\r\n![b6bbabf63d15ce4e296783a38208193.jpg](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4b94e19d7f344619b6acea31f2cebb46~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n## 打游戏\r\n大学时候沉迷英雄联盟。后来沉迷云顶之弈，现在沉迷金铲铲之战。\r\n\r\n中午午休都不要了，上分要紧，毕竟回家就得带娃了。附一下我的战绩，赛季大师是最低标准：\r\n\r\n![cf2eb2612724ed5e331d2c248afdd41.jpg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e663e58a83184ab9842b5c6548b9beec~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n# 2022下半年立flag\r\n来个谐音梗（3-8）的flag清单\r\n- [ ] 学会three\r\n- [ ] 掘金等级到4级\r\n- [ ] 看5本书（非小说）\r\n- [ ] 游戏场次降到60把以内\r\n- [ ] 多陪妻子\r\n- [ ] 教会宝宝喊爸爸~\r\n\r\n\r\n就这么多吧，躺平人不该立太多flag。点个赞表示你也玩金铲铲呀：giegie,这个赞可以给我吗？"
    },
    {   "snapshot": "",
        "title": "程序员如何实现财富自由",
        "preview": "程序员如何实现财富自由？今天我想和大家聊聊这个事情。 财富自由应该是所有人的终极目标，但实现财富自由似乎是一件不太可能的事情，即使程序员的平均工资已经非常高了。",
        "author": "brickspert",
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/1aa4b1e03382c418c9742465900a0881~300x300.image",
        "content": "> 本篇文章是 B 站视频《程序员如何实现财富自由》的文字版，欢迎大家直接去 B 站观看视频，体验更佳。B 站搜索「前端技术砖家」，关注不迷路。\r\n> \r\n> <img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/70f4689a021d48a6920d84b4ae1484ff~tplv-k3u1fbpfcp-zoom-1.image\\\" width='300px' />\r\n\r\n\r\n程序员如何实现财富自由？今天我想和大家聊聊这个事情。\r\n\r\n财富自由应该是所有人的终极目标，但实现财富自由似乎是一件不太可能的事情，即使程序员的平均工资已经非常高了。\r\n\r\n我个人经常在想，当我财富自由的时候，可以不用上班，可以做自己喜欢的事情，可以天天躺着，天天打游戏，想想都美滋滋。\r\n\r\n那怎么实现财富自由呢？今天想和大家交流下。\r\n\r\n首先我们需要先定义清楚什么是财富自由。\r\n\r\n财富自由是有一千万？一个亿？十个亿？还是多少钱？\r\n\r\n我认为都不是，财富自由应该是你的“睡后收入”能满足你的日常支出。这里注意是睡觉的睡，也就是你每天啥也不用干，光睡觉，就有收入，这些收入还能满足你的消费。哪里有这么好的事情呢？\r\n\r\n举个例子，你有十套房子，每套房子月租金一万，那你每个月的被动收入就是十万，这个就叫睡后收入，也叫被动收入。\r\n\r\n请问每个月躺着挣十万，是不是财富自由，我觉得太是了，做梦都能笑醒。\r\n那么问题来了，去哪里领十套房子？(开玩笑~\r\n\r\n所以如果想实现财富自由，我们就需要去追求被动收入。那对我们程序员来讲，被动收入有哪些渠道呢？我来列举几个例子：\r\n\r\n1. 出租房子/商铺的租金\r\n1. 长期投资的股票/基金的收益和分红\r\n1. 你做了一个比较好的付费 APP，持续能带来收益\r\n1. 你写了一本比较好的书，每年都能卖出去很多\r\n1. 你制作了一套教程或视频，每年都有人买（比如掘金课程、慕课视频等）\r\n   ![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4664a4b25d6c4782b06157b152f17e17~tplv-k3u1fbpfcp-zoom-1.image)![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3dec365dfa7b41078b8a6198a8ccaa4a~tplv-k3u1fbpfcp-zoom-1.image)\r\n1. 你写了一个商城网站，源码放在网上付费下载\r\n1. 做一个 SEO 排名非常高的网站，靠广告带来持续收益（比如测网速、编码解码等网站）\r\n   ![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b2680a7bf364b3b972905b8fb2d6be9~tplv-k3u1fbpfcp-zoom-1.image)![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dcb906f50a6b4551aa9e9f61223c353c~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n类似这种有长尾收益的事情，我觉得都是被动收入。你能想到其它哪些事情？欢迎留言交流~\r\n\r\n虽然我们知道了财富自由是什么，知道了被动收入，但似乎实践起来非常难，有无从下手的感觉。\r\n\r\n那是因为我们没有制定清晰的可执行的目标。\r\n\r\n假如我们制定一个目标 “五年之后，每月被动收入达到 2 万元”，然后我们再按年和类型拆解一下：\r\n\r\n![screenshot-20220912-191936.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/27c345e3c9164386a2ea79997e1dd5ea~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n拆解完成之后，我们会发现，似乎也不是不可能完成的，如果太难，那我们就改成 6 年、7 年、10 年，也都是可以的。\r\n\r\n当然以上仅仅是我举的例子，为了说明目标拆分后，确实具备一定的可行性，大家应该按照自己的实际条件去拆解目标。\r\n\r\n有些朋友可能会问了，那你有实现财富自由吗？\r\n\r\n那必然是没有的，如果有的话我现在就在睡觉了，而不是在录视频。我现在也处于目标拆解阶段，后面有进度的话会和大家分享交流。\r\n\r\n最后我想说：如果你不开始，那你永远不可能达到目标，让我们一起向财富自由进发！\r\n\r\n欢迎大家关注我的公众号《**前端技术砖家**》，一起加群划水聊天。\r\n"
    },
    {   "snapshot": "https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d412471382644c51a87bb3d8bb128b77~tplv-k3u1fbpfcp-watermark.image?",
        "title": "分享 11 张巨好看的PC端界面！！！",
        "preview": "今天给大家带来了11张我觉得不论从视觉效果还是页面布局的维度都特别nice的11个pc偏管理端的界面，希望大家可以在平时开发没有灵感时用来做参考。",
        "author": "HoMeTown",
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/e6cbeb2f552e010a8f3b56ac0fe2c68d~300x300.image",
        "content": "---\r\ntheme: condensed-night-purple\r\n---\r\n\r\n## 前言\r\n大家好，我是**HoMeTown**。\r\n\r\n今天给大家带来了11张我觉得不论从`视觉效果`还是`页面布局`的维度都特别nice的11个pc偏管理端的界面，希望大家可以在平时开发没有灵感时用来做参考。\r\n\r\n11张图里，我最喜欢的是`7森林`&`9国际`，你喜欢哪种风格呢？评论区说一说吧！\r\n\r\n## 1 悸动\r\n这个界面采用了粉色+紫色的双拼配色，给人一种特别有活力的感觉！\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8d678da566c641c092d8489c45ef15e0~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n## 2 简约\r\n这个图排版布局上都很明显可以感觉到给人的舒适感。\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5cc69292d92f44238a8a4d5cd3c098cc~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n## 3 科技\r\n这张图我总感觉有那种iOS的那种科技风，可以用来做电子产品的pc页面\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dcdd2ae88d79440b9a4dff038fea9c1f~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n## 4 橙光\r\n这张图的配色和布局我和之前一家公司的风格很像，做SaaS服务的经典配色。\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/44b2c65ef22a4765ab0ec5e5e722e60e~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n## 5 柔和\r\n这张图看上去就比较柔和一点，除了左上角的卡片有点炸眼。\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ed662869eba643c9923d4e232a35a96d~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n## 6 森林\r\n这个图就不用说了吧，是我最喜欢的颜色和风格，贴近大自然，强烈推荐👍🏻。\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d1dc81bc258409c85ef53e483a44361~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n## 7 清新\r\n这张图就很清新啦，适合做化妆品类的网站\r\n\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc4312360e1e45fc97249372c2f10942~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n## 8 传统\r\n感觉这个风格有点点偏传统，但是又有一点科技风的感觉。\r\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/81008a09a0e944488b0e63a7113d5e9b~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n## 9 国际\r\n这张图有了上面几个card的颜色点缀，感觉瞬间提升b格。\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a8393887a4c40b2acc605db9a322b78~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n## 10 丰富\r\n这张图的重点在布局，可以在页面元素多的时候，给我们一个参考。\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8dbe051bee6487b915d90357273d30a~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n## 11 简洁\r\n以单一的白色作为大背景色，崇尚极简！而且有没有人觉得右下角那个图有点像掘金的图？\r\n\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a1559cab2bc472a9317f5633a77d3d0~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n以上所有设计图均来自网络，如有侵权，请call我删除，感谢~\r\n\r\n## 实践实践？\r\n大家可以把觉得不错的界面投到评论区，过段时间我会统计一下得到赞同数最多的，然后做一个网页出来开源分享给大家。\r\n\r\n## 完结\r\n> 下次见~ 我的朋友，我是`HoMeTown`👨‍💻‍，➕我VX，💊你进群，这是一个大家共同成长、共同学习的社群！在这里你可以：讨论技术问题、了解前端资讯、打听应聘公司、获得内推机会、聊点有的没的。\r\n> \r\n> 👉 vx: `hometown-468`【单独拉你】\r\n> \r\n> 👨‍👩‍👧 公众号：`秃头开发头秃了` 【关注回复“进群”】\r\n> \r\n> 🤖 Blog：[HoMeTown'Blog](https://blog.ishometown.com/)【点开看看】\r\n\r\n## 高赞好文\r\n- [敢在我工位装摄像头？吃我一套JS ➕ CSS组合拳！！👊🏻](https://juejin.cn/post/7135994466006990856)\r\n\r\n- [前端老司机 70+ 实用工具网站分享（建议收藏！）🔥🔥](https://juejin.cn/post/7129412947931037732)\r\n\r\n- [前端老司机 70+ 实用工具网站分享（建议收藏！）🔥🔥](https://juejin.cn/post/7129412947931037732)\r\n\r\n- [【Git】 什么！？都快2023年了还搞不清楚 git rebase 与 git merge！？😮](https://juejin.cn/post/7135261815935598600)\r\n\r\n- [ 我用前端【最新】技术栈完成了一个生产标准的项目【Vue3 + TS + Vite + Pinia + Windicss + NavieUI】](https://juejin.cn/post/7101943469085556766)\r\n\r\n## 往期回顾\r\n- [🤷‍♂️ 怒砸 30w+ 矿石抽礼盒后，我通透了...【掘金 · 幸运大转盘Vue3版】](https://juejin.cn/editor/drafts/7139833860149215240)\r\n\r\n- [巧用NodeJs帮老板解决个人需求！老板娘直呼：\\\"牛！niu！🐂！\\\"](https://juejin.cn/post/7138656718694645767)\r\n\r\n- [使用eslint + prettier + husky + lint-staged 约束项目的最佳实践！](https://juejin.cn/post/7127829940380106782)\r\n\r\n- [【小程序】爆肝 3 天总结的微信小程序优化指南（收藏夹吃灰吧！）🔥🔥](https://juejin.cn/post/7127448103908556831)\r\n\r\n- [【VUE】从源码角度说清楚MVVM！实现v-model！真的很简单！🔥](https://juejin.cn/post/7126714556730048519)\r\n\r\n- [【CSS】5分钟带你彻底搞懂 W3C & IE 盒模型！🔥🔥](https://juejin.cn/post/7124859308331761671)\r\n\r\n- [【CSS】有意思的BFC：Block Formatting Context（块格式化上下文）！🤡](https://juejin.cn/post/7125229317826543652)\r\n\r\n- [【CSS】聊一聊CSS像素、设备像素、设备独立像素、dpr、ppi 之间的区别](https://juejin.cn/post/7125980324596547620)\r\n\r\n- [【性能】7分钟带你了解【尤大】都在使用的 Chrome Runtime Performance Debug！](https://juejin.cn/post/7102990967162503181)\r\n\r\n- [ 【源码角度】7分钟带你搞懂ESLint核心原理！](https://juejin.cn/post/7102620286675058725)\r\n\r\n- [ 【JavaScript】手把手教你写高质量 JavaScript 异步代码！](https://juejin.cn/post/7102240670269571109)\r\n\r\n- [ ............... 查看更多 ............... ](https://juejin.cn/user/4116184668057390)\r\n"
    },
    {   "snapshot": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88b71db5b68d49419a686d926e58df70~tplv-k3u1fbpfcp-watermark.image?",
        "title": "前端工作一年半，离职了！！！",
        "preview": "哈喽~，大伙儿好久不见。今天爬上来唠唠，是因为最近向公司主动提出离职了，这几天刚办理完。这是小鹿的第一份工作，算是正式画上了一个句号，我觉得有很多经历需要在这里记录分享一下。 从 2020 年 8 月",
        "author": "程序员小鹿",
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/71175455eb2ef6f4f67065569e6304dc~300x300.image",
        "content": "---\r\ntheme: juejin\r\n---\r\n> 前段时间写的一篇文章，一直没有更新，最近工作节奏慢下来了，就爬上来更新一波。\r\n\r\n哈喽~，大伙儿好久不见。今天爬上来唠唠，是因为最近向公司主动提出离职了，这几天刚办理完。这是小鹿的第一份工作，算是正式画上了一个句号，我觉得有很多经历需要在这里记录分享一下。\r\n\r\n从 2020 年 8 月 4 日入职老东家起，到 2022 年 4 月15 日正式离职，已经有一年半左右的时间了。在这短短的一年半时间里发生了很多的事情，业务的改变，人员的变动，自我的成长，也经历了一个创业公司从初期到中期的发展。\r\n\r\n在这里想总结一下，这过去的一年半时间里，能够影响到我以及改变到我的东西。那就按照时间线来吧~\r\n\r\n## 1、初入职场\r\n\r\n从学校到职场，我的第一个想法就是能够尽快让自己成长起来，无论是技术能力、思考能力、沟通能力以及其他能力等等，这将影响到我以后的路好不好走。所以在疫情之下，就很幸运的入职了老东家。\r\n\r\n\r\n初入职场避免不了经常犯错误，把 git 分支玩坏，代码提交不规范，逻辑思路混乱这是常常犯的低级错误。\r\n\r\n\r\n正是由于 leader 和前辈给了很多包容和让我试错的机会，也在短时间之内逐渐成长了起来，慢慢的适应了当下的环境，逐步对自己有了更高的要求。\r\n\r\n\r\n其实这段时间是自我成长最快的一段时期。\r\n\r\n## 2、出差\r\n\r\n待了半年左右，老东家正好有一个出差的项目要去面对面和客户负责，当时内部也是比较缺人，所以主动申请了。\r\n\r\n\r\n其实我心里也没底能不能把这次任务做好，只是觉得机会是很难得，所以就争取了下来。\r\n\r\n\r\n在出差的这三个多月里，对公司的产品有了更进一步的了解，也对这个金融行业有了更深的认识，当然个人的沟通协调能力也得到了大幅度的提升，也逐渐总结出了自己处理事情的方式和方法，这让我在接下来的发展中能够更加顺利。\r\n\r\n\r\n在提高能力和学到知识的同时，老东家也给了我许多的激励和奖励。也许就在这一刻，我感受到自己的巨大成长，逐渐能够担任技术之外的一些责任。\r\n\r\n## 3、迷茫\r\n\r\n成长的同时伴随着迷茫的产生，我在哪？我是谁？我要干什么？\r\n\r\n有一段时间，我突然陷入了一个低谷期，不知道下面的路如何走，这也是我最焦虑的一段时间。\r\n\r\n\r\n站在现在的角度去看当初，其实这个低谷期就是从一个山峰到另一个山峰中间的山谷。引用温伯格大牛在《如何成为技术领导者》书中提到的提高能力的两种模式，一种叫做渐进模式，另一种叫做跃迁模式，而上述所提到的就是跃迁模式结构。\r\n\r\n\r\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9a671de53e4a499499e9b87536aee891~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n就是每当你进行新的挑战时，一开始能力水平是低于之前上一个挑战能力水平的，但是当你逐渐的去训练自己，慢慢的把能力提升上来之后，就会超过于上一次挑战获得的能力水平。\r\n\r\n\r\n突破迷茫的关键点在于如何寻找更大挑战的事情。\r\n\r\n\r\n## 4、裁员\r\n\r\n到了 21 年年底，公司迎来了第一次大规模裁员。如果你问我当时慌不慌，说实话，已经做好被裁的准备，因为应对黑天鹅最好的办法就是提高自己反脆弱的能力。（给大伙儿推荐《反脆弱》这本经典书籍）\r\n\r\n\r\n当然，像裁员这波操作其实很多人可以提前做出决策，这就要分析创业公司整个发展过程以及遇到的实质性障碍是什么，大约会发展到什么阶段会出现裁员（疫情虽然有影响，但是关键并不是外界环境所致），这个有机会会单独写一篇跟大伙儿唠唠~\r\n\r\n\r\n这次裁员，走了一些之前一起合作的同事，公司业务和结构也发生了很大的改变，这一次的变动让我更加明白自己想要什么，想要往哪个方向发展和提高。\r\n\r\n\r\n## 5、离职\r\n\r\n\r\n4 月初，我正式提出离职。也许这个想法在我心内争斗了许久，最后还是决定了。离职的原因很简单，自我优化。\r\n\r\n\r\n\r\n其实一开始入职的时候就想过，当我不能够为公司提供更多的价值以及自己能力在当下环境不能够得到提升，就要考虑换个环境了，越早跳出舒适圈，对自己来说是有利的。\r\n\r\n\r\n还有一个比较重要的原因就是做的事情要有长期的价值。这不得不让我想起一个比较有思考性的问题。\r\n\r\n\r\n在这里想问一下大伙儿，在这个互联网时代，我们所拿到的薪资水平真的和自己的能力所匹配么？你怎么判定自己所产生的的价值是多少？\r\n\r\n\r\n\r\n当然，当我们面对“价值”两个字时，不同的角度会有不同的认定，比如站在公司角度，可能会受到利益的驱动，从而会否定你产生的价值。如果站在客户角度，增加了他的办公效率，可能会认可你所产生的价值。\r\n\r\n\r\n你到底产生多少有用的价值，其实这一点很值得我们每个人去思考。后续在写面试系列的文章中会重点说一下“工作价值”在面试过程中体现出来的作用。\r\n\r\n\r\n## 小结\r\n\r\n过去的已经过去吧，未来还有很长一段路要走。坚持自己学技术的初衷，希望能够为社会发展带来一点点的作用。在工作的同时不断寻求属于自己的出路，争取有一天能够摆脱打工人的角色。\r\n\r\n加油:)\r\n\r\n"
    },
    {   "snapshot": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fc554b83ba674a4e945d48d27e31380d~tplv-k3u1fbpfcp-watermark.image?",
        "title": "为什么B站的弹幕可以不挡人物",
        "preview": "那天在B站看视频的时候偶然发现当字幕遇到人物的时候就被裁切了，不会挡住人物，觉得很神奇，于是决定一探究竟。",
        "author": "钱得乐",
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/1ba304f06bb6a5d442791cec0c809d4d~300x300.image",
        "content": "---\r\ntheme: channing-cyan\r\n---\r\n“我报名参加金石计划1期挑战——瓜分10万奖池，这是我的第1篇文章，[点击查看活动详情](https://s.juejin.cn/ds/jooSN7t \\\"https://s.juejin.cn/ds/jooSN7t\\\")”\r\n\r\n那天在B站看视频的时候偶然发现当字幕遇到人物的时候就被裁切了，不会挡住人物，觉得很神奇，于是决定一探究竟。\r\n\r\n高端的效果，往往只需要采用最朴素的实现方式，忙碌了两个小时，陈师傅打开了F12，豁然开朗。一张图片+一个属性，直接搞定。\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e91ac49115ac405290f79a02b440aaf0~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/680022c4c16845a983999cc4bc934bc5~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n为了印证我的想法，我决定自己写一个demo\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\\\"en\\\">\r\n<head>\r\n  <meta charset=\\\"UTF-8\\\">\r\n  <title>Title</title>\r\n  <style>\r\n    .video {\r\n      width: 668px;\r\n      height: 376px;\r\n      position: relative;\r\n      -webkit-mask-image: url(\\\"mask.svg\\\");\r\n      -webkit-mask-size: 668px 376px;\r\n    }\r\n    .bullet {\r\n      position: absolute;\r\n      font-size: 20px;\r\n    }\r\n  </style>\r\n</head>\r\n<body>\r\n<div class=\\\"video\\\">\r\n  <div class=\\\"bullet\\\" style=\\\"left: 100px; top: 0;\\\">元芳，你怎么看</div>\r\n  <div class=\\\"bullet\\\" style=\\\"left: 200px; top: 20px;\\\">你难道就是传说中的奶灵</div>\r\n  <div class=\\\"bullet\\\" style=\\\"left: 300px; top: 40px;\\\">你好，我是胖灵</div>\r\n  <div class=\\\"bullet\\\" style=\\\"left: 400px; top: 60px;\\\">这是第一集，还没有舔灵</div>\r\n</div>\r\n</body>\r\n</html>\r\n```\r\n效果是这样的\r\n\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/18edc012136d4d659242399c3519b820~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n加一个红背景，看的清楚一些\r\n\r\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/177f837aabb74a0196d9f8f69bbfd6c0~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n至此我们就实现了B站同款的不遮挡人物的弹幕。至于这张图片是怎么来的，肯定是AI识别出来然后生成的，一张图片也就一两K，一次加载很多张也不会造成很大的负担。\r\n\r\n最后来看看这个神奇的css属性吧\r\n\r\nhttps://developer.mozilla.org/zh-CN/docs/Web/CSS/mask-image\r\n\r\n**Experimental:**  **这是一个实验中的功能**\r\n\r\n所以在开发需求的时候可以把它当成一个亮点使用，但是不能强依赖于这个属性做需求。\r\n\r\n它还有一系列的属性，有兴趣的话可以挨个试一下。\r\n\r\n\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/633cf9cb8b48443da0b69179315df68a~tplv-k3u1fbpfcp-watermark.image?)\r\n"
    },
    {   "snapshot": "https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/720d976d5b5947c187b8f7039126c10e~tplv-k3u1fbpfcp-watermark.image?",
        "title": "一个96年前端的2022年中总结 (落户,看房,还贷,被裁)",
        "preview": "「时光不负，创作不停，本文正在参加2022年中总结征文大赛」 落户 关于落户这个事, 就是一个很突然的想法,很突然, 得知天津有个\"海河英才计划\",只要是本科生, 就比较容易落户,所以就想着试一试, ",
        "author": "nanfeiyan",
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/5ea3565b463e60f37108c850425cebd6~300x300.image",
        "content": "---\r\ntheme: fancy\r\nhighlight: arduino-light\r\n---\r\n\r\n\r\n「时光不负，创作不停，本文正在参加[2022年中总结征文大赛](https://juejin.cn/post/7108989863126368286)」\r\n\r\n\r\n> 人到中年中年总是觉得很累,每天忙不完的事,操不完的心,曾今那些无忧无虑的日子似乎消失的无影无踪, 工作三年一点存款没有\r\n\r\n\r\n### 落户\r\n关于落户这个事, 就是一个很突然的想法,很突然, 得知天津有个\\\"海河英才计划\\\",只要是本科生, 就比较容易落户,所以就想着试一试, 心想起码这个是一个阶级的跨越(农村-->城市), 然后就在网上各种搜索,问一些了解的朋友,看看怎么操作, 最后发现好多人说有北京社保,在天津落户会被查出来, 然后就被拉入黑名单了. 最后为了稳妥还是找了一个中介帮忙操作了一下,花了1w, 等我办完,不久就有我的朋友自己办的三无人员落户, 一分钱没花. 唉😌!!!!! \r\n\r\n### 看房\r\n一开始在安居客上看, 因为穷, 基本也没啥可选择性, 一筛选也就那么几个, 然后就联系了一个销售去看房, 不得不说这个销售真的可以, 不知道他们能赚多少钱哈, 但是服务是真的不错, 一到了高铁站他们就去接你,还请你吃饭, 带着你看,看完之后还把你送到高铁站. 想着一开始就看西青和北辰的,但是西青的都好贵, 北辰好像会好点, 然后就去北辰看, 销售说他觉得武清也不错, 就带着去武清也看了, 看完之后, 心里比较了一下, 感觉被武清的哪个样板间和户型深深吸引了,并且价格也比较合适些, 然后我回到北京一周左右吧, 就跟那个销售说,打算买武清哪个, 然后然后我父母给我拿了20w, 剩下的就是我自己的,还借了朋友一些, 首付了40多, 然后就打印征信, 一顿签字就买了. 感觉很随意, 感觉买房就跟买菜似的, 不过还是有一点区别的, 买菜之后不会让我身无分文, 买房会😭. 现在就是每个月5000多贷款\\\"真爽\\\".\r\n\r\n\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca57b09486634e81b4bab8d0e3b49e02~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n### 学习\r\n1. 缺失了刚毕业那会的激情,刚毕业那会,每天下班还会去学习, 刷视频, 看文章, 现在下班回家已经不想再打开电脑了. 刷视频(此视频非彼视频)\r\n2. 今年也学习了一些新的东西摸鱼之间,刷了一些课程,<破解JavaScript高级玩法，成为精通JS的原生专家>  <Vue3全家桶>\r\n3. React技术栈是我工作一直使用的,也会持续性的学习一些,每天刷刷Medium和掘金\r\n4. 深度学习Nginx,进行了一半了,以前对nginx只停留在使用的层面\r\n5. 上半年在公司分享了一下架手架的原理以及实践\r\n6. 英语的学习说实话真的有点三天打鱼两天晒网了, 好在现在有一半了\r\n\r\n![img_1.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/07a50f34a7a64fc794d292f47f4f806f~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n\r\n### 工作\r\n21年年底, 老东家北京这边合作的项目,终止了,然后面临了裁员, 不过当初也确实有了想跳槽的想法了,本来想,等到年终奖发了,就提离职. 没想到提前到来了, 给了正常的赔偿(n+1) 拿了三个月的赔偿, 正好月底, 算上本月的薪资,还有一些调休啥的 加起来一共是4个月, 感觉还挺爽的, 因为大概还有个20天左右吧, 就快过年了, 然后在回家和找工作抉择了一下, 决定先找找工作,然后就开始学习在掘金上查看面经, 感觉都是各种源码, 给我搞的有点懵, 毕竟缺钱嘛. 先后面试了一些公司: 金山, 58, 携程, 欢聚, 等等; 说实话,这段时间招人的还挺多的. 所以我很快就入职了, hr问我年前能入职吗? 其实那段时间疫情严重了, 老家那边也不让北京的回去, 所以在过年的前一周我入职了, (没钱的人不配拥有假期😭) . 唉, 第一次自己在外地过年.\r\n\r\n\r\n\r\n关于兼职: \r\n- 今年和朋友一块干了一个公司的官网,本来也没打算要钱的,最后老板一人给了一张京东e卡\r\n- 还干了一个审核ppt的工作,一个ppt给150,不用改, 就说哪里写的不合适, 不过这个活有点恶心, 每个人理解不一样, 每次我这边审核后, 拿去交付,还是很多问题\r\n\r\n### 生活\r\n1. 上半年感觉一直有疫情断断续续,大家都比较封闭,也没出去玩过, 偶尔和朋友去爬个山. 5, 6月还居家办公了好久, 记不太清了,应该得有一个月\r\n2. 从去年十月一到现在一直没有回过家, 有些想回去看看, 但是最近每个周末都有事😞\r\n3. 和女朋友去看过两次脱口秀, 感觉现场的感觉还是很棒的, 比电视看好太多\r\n4. 因为对象住他们单位的宿舍, 所以我自己平常下班也懒得收拾屋子, 只有礼拜天,才会大扫除一下, 或者对象来的时候😁\r\n5. 前段时间迷上了王者,以前从来不怎么玩游戏的, 熬夜打游戏, 导致生活节奏有点乱, 每天的精神状态也不如以前,正在积极调整. 但是吧,我告诉你们我的云中君玩的贼6的 不服来战哦\r\n6. 养了一只鹦鹉, 刚来还不是很好看, 现在尾巴长长的了\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f07e2be4fbb1445bae3ad991633fa388~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n\r\n### 下半年flag\r\n- [ ] 完成Nginx的深度学习\r\n- [ ] 希望能出去转一圈, 看看外面的世界\r\n- [ ] 继续背单词学习\r\n- [ ] 看看车车, 目前感觉Crv和宋大妈还不错\r\n- [ ] 能再进行一次有价值的分享\r\n\r\n"
    },
    {   "snapshot": "https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/29e60157d74848d2ae0f8ff01372f2b4~tplv-k3u1fbpfcp-watermark.image?",
        "title": "一起写个vite吧！(2) --插件机制开发",
        "preview": "“我正在参加「掘金·启航计划」”，这是mini-vite系列的第二篇文章，很多同学只知道vite很快，但却不知道它快在哪里，这一系列文章就和大家一起实现一个vite，一起学习vite的原理。",
        "author": "鲁类类丢",
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/b35a71e80fda4602121fa5f8613d3215~300x300.image",
        "content": "---\r\ntheme: fancy\r\nhighlight: tomorrow\r\n---\r\n“我正在参加「掘金·启航计划」”\r\n\r\n\r\n> 继上一章节[一起写个vite吧！(1) --环境搭建+依赖预构建](https://juejin.cn/post/7154007357305913357)咱们继续开干哈，这一节咱们来搞`vite`的插件机制的实现，干货满满哈。`vite`在开发的阶段实现了一个按需加载的服务器，每个文件请求进来都会经历一系列的编译流程，生产环境下,`vite`同样会执行一系列编译过程，将编译结果交给 `Rollup` 进行模块打包。这一系列的编译过程指的就是 `Vite` 的插件工作流水线(Pipeline)，而插件功能又是 `Vite` 构建能力的核心，因此谈到阅读 `Vite` 源码，我们永远绕不开插件的作用与实现原理。\r\n-   在生产环境中 `Vite` 直接调用 `Rollup` 进行打包，所以 `Rollup` 可以调度各种插件；\r\n-   在开发环境中，`Vite` 模拟了 `Rollup` 的插件机制，设计了一个`PluginContainer` 对象来调度各个插件。\r\n\r\n> 值得一提的是 `Vite` 从 `preact` 的 `WMR` 中得到了启发，把插件机制做成**兼容 Rollup** 的格式。简单的介绍一下 `Rollup` 插件，其实插件这个东西，就是 `Rollup` 对外提供一些运行过程中一些时机的钩子，还有一些工具方法，让用户去写一些配置代码，以此介入 `Rollup` 运行的各个时机之中。而 `Vite` 需要做的就是基于 `Rollup` 设计的接口进行扩展，在保证 `Rollup` 插件兼容的可能性的同时，再加入一些 `Vite` 特有的钩子和属性来扩展。`Rollup`的插件可以参考这篇文章[Rollup 之插件机制浅析](https://juejin.cn/post/6968641190061309960)。\r\n\r\n1.  实现 Rollup 插件钩子的调度\r\n2.  实现插件钩子内部的 Context 上下文对象\r\n\r\nVite架构图：\r\n\r\n![02910cd2c6894bcdb3a9e0fc9e59f4c2_tplv-k3u1fbpfcp-zoom-in-crop-mark_3024_0_0_0.webp](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3cd4fa84cdb84413b8d193de1a4acf77~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n对于`vite`的插件API可以直接看一下[官网的插件API介绍](https://cn.vitejs.dev/guide/api-plugin.html)，任何可以自己编写一下`vite`的插件，官网有一个虚拟模块插件的例子，可以看看自己跟着写一写--[虚拟模块插件demo地址](https://cn.vitejs.dev/guide/api-plugin.html#virtual-modules-convention)。\r\n\r\nok同学们在官网熟悉完插件后，咱们正式进入插件机制的开发，在这里我们并不会实现`vite`的所以插件哈，只会实现部分。\r\n\r\n## pluginContainer的实现\r\n\r\n插件容器需要接收 Vite 插件作为初始化参数，因此我们需要提前声明插件的类型，你可以继续新建`src/node/plugin.ts`来声明如下的插件类型:\r\n\r\nsrc/node/plugin.ts\r\n\r\n\r\n```ts\r\nimport { LoadResult, PartialResolvedId, SourceDescription } from 'rollup'\r\n\r\nimport { ServerContext } from './server'\r\n\r\nexport type ServerHook = (\r\n  server: ServerContext\r\n) => (() => void) | void | Promise<(() => void) | void>\r\n\r\n// 只实现以下这几个钩子\r\nexport interface Plugin {\r\n  name: string\r\n  configureServer?: ServerHook\r\n  resolveId?: (\r\n    id: string,\r\n    importer?: string\r\n  ) => Promise<PartialResolvedId | null> | PartialResolvedId | null\r\n  load?: (id: string) => Promise<LoadResult | null> | LoadResult | null\r\n  transform?: (\r\n    code: string,\r\n    id: string\r\n  ) => Promise<SourceDescription | null> | SourceDescription | null\r\n  transformIndexHtml?: (raw: string) => Promise<string> | string\r\n}\r\n\r\n```\r\n\r\nok然后我们再新建`src/node/pluginContainer.ts`文件，增加类型定义:\r\n\r\nsrc/node/pluginContainer.ts\r\n```\r\n// rollup里的类型，vite是基于rollup的插件进行拓展的\r\nimport type {\r\n  LoadResult,\r\n  PartialResolvedId,\r\n  SourceDescription,\r\n  PluginContext as RollupPluginContext,\r\n  ResolvedId,\r\n} from \\\"rollup\\\";\r\n\r\nexport interface PluginContainer {\r\n  resolveId(id: string, importer?: string): Promise<PartialResolvedId | null>;\r\n  load(id: string): Promise<LoadResult | null>;\r\n  transform(code: string, id: string): Promise<SourceDescription | null>;\r\n}\r\n```\r\n\r\nok，然后我们来实现插件机制的具体逻辑，主要集中在`createPluginContainer`函数中:\r\n\r\nsrc/node/pluginContainer.ts\r\n\r\n\r\n```ts\r\nimport type {\r\n  LoadResult,\r\n  PartialResolvedId,\r\n  SourceDescription,\r\n  PluginContext as RollupPluginContext,\r\n  ResolvedId,\r\n} from 'rollup'\r\nimport { Plugin } from './plugin'\r\n\r\nexport interface PluginContainer {\r\n  resolveId(id: string, importer?: string): Promise<PartialResolvedId | null>\r\n  load(id: string): Promise<LoadResult | null>\r\n  transform(code: string, id: string): Promise<SourceDescription | null>\r\n}\r\n\r\nexport const createPluginContainer = (plugins: Plugin[]): PluginContainer => {\r\n  // 插件上下文对象\r\n  // 使用ts-ignore让ts不检查这里的Context，因为我们只实现上下文对象的 resolve 方法，会报错\r\n  // @ts-ignore \r\n  class Context implements RollupPluginContext {\r\n    async resolve(id: string, importer?: string) {\r\n      let out = await pluginContainer.resolveId(id, importer)\r\n      if (typeof out === 'string') out = { id: out }\r\n      return out as ResolvedId | null\r\n    }\r\n  }\r\n  // 插件容器\r\n  const pluginContainer: PluginContainer = {\r\n    async resolveId(id: string, importer?: string) {\r\n      const ctx = new Context() as any\r\n      for (const plugin of plugins) {\r\n        if (plugin.resolveId) {\r\n          const newId = await plugin.resolveId.call(ctx as any, id, importer)\r\n          if (newId) {\r\n            id = typeof newId === 'string' ? newId : newId.id\r\n            return { id }\r\n          }\r\n        }\r\n      }\r\n      return null\r\n    },\r\n    async load(id) {\r\n      const ctx = new Context() as any\r\n      for (const plugin of plugins) {\r\n        if (plugin.load) {\r\n          const result = await plugin.load.call(ctx, id)\r\n          if (result) {\r\n            return result\r\n          }\r\n        }\r\n      }\r\n      return null\r\n    },\r\n    async transform(code, id) {\r\n      const ctx = new Context() as any\r\n      for (const plugin of plugins) {\r\n        if (plugin.transform) {\r\n          const result = await plugin.transform.call(ctx, code, id)\r\n          if (!result) continue\r\n          if (typeof result === 'string') {\r\n            code = result\r\n          } else if (result.code) {\r\n            code = result.code\r\n          }\r\n        }\r\n      }\r\n      return { code }\r\n    },\r\n  }\r\n\r\n  return pluginContainer\r\n}\r\n\r\n```\r\n> 很显然，`Vite` 将 `Rollup` 的 `PluginContext` 对象重新实现了一遍，因为只是开发阶段用到，所以去除了一些打包相关的方法实现，我们这里则只实现上下文对象`reslove`方法而已，在调用钩子用`call`绑定this这样在钩子里可以通过`this.XXXX`调用上下文里的`XXXX`方法了。\r\n\r\nok然后我们再去完善服务器的逻辑\r\n\r\nsrc/node/server/index.ts\r\n\r\n\r\n```ts\r\nimport connect from 'connect'\r\n// picocolors 是一个用来在命令行显示不同颜色文本的工具\r\nimport { blue, green } from 'picocolors'\r\nimport { optimize } from '../optimizer'\r\nimport { resolvePlugins } from '../plugins'\r\nimport { Plugin } from '../plugin'\r\nimport { createPluginContainer, PluginContainer } from '../pluginContainer'\r\n\r\n// 服务器上下文的类型\r\nexport interface ServerContext {\r\n  root: string\r\n  pluginContainer: PluginContainer\r\n  app: connect.Server\r\n  plugins: Plugin[]\r\n}\r\n\r\nexport async function startDevServer() {\r\n  const app = connect()\r\n  const root = process.cwd()\r\n  const startTime = Date.now()\r\n  const plugins = resolvePlugins()\r\n  const pluginContainer = createPluginContainer(plugins)\r\n\r\n  const serverContext: ServerContext = {\r\n    root: process.cwd(),\r\n    app,\r\n    pluginContainer,\r\n    plugins,\r\n  }\r\n\r\n  for (const plugin of plugins) {\r\n    if (plugin.configureServer) {\r\n      await plugin.configureServer(serverContext)\r\n    }\r\n  }\r\n\r\n  app.listen(3000, async () => {\r\n    await optimize(root)\r\n    console.log(\r\n      green('🚀 No-Bundle 服务已经成功启动!'),\r\n      `耗时: ${Date.now() - startTime}ms`\r\n    )\r\n    console.log(`> 本地访问路径: ${blue('http://localhost:3000')}`)\r\n  })\r\n}\r\n\r\n```\r\n其中 `resolvePlugins` 方法我们还未定义，我们去新建一个`src/node/plugins/index.ts` 文件，内容如下:\r\n\r\n```\r\nimport { Plugin } from \\\"../plugin\\\";\r\n\r\nexport function resolvePlugins(): Plugin[] {\r\n  // 下一部分会逐个补充插件逻辑\r\n  return [];\r\n}\r\n```\r\n这个方法是用来加载插件的，后面我们编写的插件在这里引用并返回出去\r\n\r\n## 入口HTML加载中间件\r\n\r\nok那我们首先要考虑的就是入口 HTML 如何编译和加载的问题，这里我们可以通过一个服务中间件，注意哈这个是中间件不是插件，是connect的中间件，跟koa和express的中间件是差不多的。然后配合我们的插件机制来实现。我们可以新建`src/node/server/middlewares/indexHtml.ts`，内容如下:\r\n\r\nsrc/node/server/middlewares/indexHtml.ts\r\n\r\n```ts\r\nimport { NextHandleFunction } from 'connect'\r\nimport { ServerContext } from '..'\r\nimport path from 'path'\r\nimport { pathExists, readFile } from 'fs-extra'\r\n\r\nexport function indexHtmlMiddware(\r\n  serverContext: ServerContext\r\n): NextHandleFunction {\r\n  return async (req, res, next) => {\r\n    if (req.url === '/') {\r\n      const { root } = serverContext\r\n      // 默认使用项目根目录下的 index.html\r\n      const indexHtmlPath = path.join(root, 'index.html')\r\n      if (await pathExists(indexHtmlPath)) {\r\n        const rawHtml = await readFile(indexHtmlPath, 'utf-8')\r\n        let html = rawHtml\r\n        // 通过执行插件的 transformIndexHtml 方法来对 HTML 进行自定义的修改\r\n        for (const plugin of serverContext.plugins) {\r\n          if (plugin.transformIndexHtml) {\r\n            html = await plugin.transformIndexHtml(html)\r\n          }\r\n        }\r\n\r\n        res.statusCode = 200\r\n        res.setHeader('Content-Type', 'text/html')\r\n        return res.end(html)\r\n      }\r\n    }\r\n    return next()\r\n  }\r\n}\r\n\r\n```\r\n接着我们在服务端应用这个中间件:\r\n\r\n```\r\n// src/node/server/index.ts\r\n// 需要增加的引入语句\r\nimport { indexHtmlMiddware } from \\\"./middlewares/indexHtml\\\";\r\n\r\n// 省略中间的代码\r\n\r\n// 处理入口 HTML 资源\r\napp.use(indexHtmlMiddware(serverContext));\r\n\r\napp.listen(3000, async () => {\r\n  // 省略\r\n});\r\n```\r\n然后我们可以通过`pnpm dev`启动项目，然后访问`http://localhost:3000`，从网络面板中你可以查看到 HTML 的内容已经成功返回:\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/248448af73a94afbbef3c59afa228bba~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n> 不过当前的页面并没有任何内容，因为 HTML 中引入的 TSX 文件并没有被正确编译。接下来，我们就来可以去处理 `TSX` 文件的编译工作。\r\n\r\n## JS/TS/JSX/TSX编译的能力\r\n\r\nok那我们先新增一个中间件`src/node/server/middlewares/transform.ts`，内容如下:\r\n\r\nsrc/node/server/middlewares/transform.ts\r\n```ts\r\n\r\nimport { NextHandleFunction } from 'connect'\r\n\r\nimport { isJSRequest, cleanUrl } from '../../utils'\r\nimport { ServerContext } from '../index'\r\nimport createDebug from 'debug'\r\n\r\nconst debug = createDebug('dev')\r\n\r\nexport async function transformRequest(\r\n  url: string,\r\n  serverContext: ServerContext\r\n) {\r\n  const { pluginContainer } = serverContext\r\n  url = cleanUrl(url)\r\n  // 简单来说，就是依次调用插件容器的 resolveId、load、transform 方法\r\n  const resolvedResult = await pluginContainer.resolveId(url)\r\n  let transformResult\r\n  if (resolvedResult?.id) {\r\n    let code = await pluginContainer.load(resolvedResult.id)\r\n    if (typeof code === 'object' && code !== null) {\r\n      code = code.code\r\n    }\r\n    if (code) {\r\n      transformResult = await pluginContainer.transform(\r\n        code as string,\r\n        resolvedResult?.id\r\n      )\r\n    }\r\n  }\r\n  return transformResult\r\n}\r\n\r\nexport function transformMiddleware(\r\n  serverContext: ServerContext\r\n): NextHandleFunction {\r\n  return async (req, res, next) => {\r\n    if (req.method !== 'GET' || !req.url) {\r\n      return next()\r\n    }\r\n    const url = req.url\r\n    debug('transformMiddleware: %s', url)\r\n    // transform JS request\r\n    if (isJSRequest(url)) {\r\n      // 核心编译函数\r\n      let result = await transformRequest(url, serverContext)\r\n      if (!result) {\r\n        return next()\r\n      }\r\n      if (result && typeof result !== 'string') {\r\n        result = result.code as any\r\n      }\r\n      // 编译完成，返回响应给浏览器\r\n      res.statusCode = 200\r\n      res.setHeader('Content-Type', 'application/javascript')\r\n      return res.end(result)\r\n    }\r\n\r\n    next()\r\n  }\r\n}\r\n\r\n```\r\n同时，我们也需要补充如下的工具函数和常量定义:\r\n\r\nsrc/node/utils.ts\r\n```\r\nimport { JS_TYPES_RE } from './constants.ts'\r\n\r\nexport const isJSRequest = (id: string): boolean => {\r\n  id = cleanUrl(id);\r\n  if (JS_TYPES_RE.test(id)) {\r\n    return true;\r\n  }\r\n  if (!path.extname(id) && !id.endsWith(\\\"/\\\")) {\r\n    return true;\r\n  }\r\n  return false;\r\n};\r\n\r\nexport const cleanUrl = (url: string): string =>\r\n  url.replace(HASH_RE, \\\"\\\").replace(QEURY_RE, \\\"\\\");\r\n  \r\n// src/node/constants.ts\r\nexport const JS_TYPES_RE = /.(?:j|t)sx?$|.mjs$/;\r\nexport const QEURY_RE = /?.*$/s;\r\nexport const HASH_RE = /#.*$/s;\r\n```\r\n\r\n> 从如上的核心编译函数`transformRequest`可以看出，Vite 对于 JS/TS/JSX/TSX 文件的编译流程主要是依次调用插件容器的如下方法:\r\n> \r\n> -   resolveId\r\n> -   load\r\n> -   transform\r\n> \r\nok接下来我们就直接来开发这些插件拉\r\n\r\n## 路径解析插件\r\n\r\n当浏览器解析到如下的标签时:\r\n\r\n```\r\n<script type=\\\"module\\\" src=\\\"/src/main.tsx\\\"></script>\r\n```\r\n\r\n会自动发送一个路径为`/src/main.tsx`的请求，但如果服务端不做任何处理，是无法定位到源文件的，随之会返回 404 状态码:\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bbee32c5d51d464f95fcc35c9978c5bc~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n因此，我们需要开发一个路径解析插件，对请求的路径进行处理，使之能转换真实文件系统中的路径。我们直接新建文件`src/node/plugins/resolve.ts`，内容如下:\r\n\r\nsrc/node/plugins/resolve.ts\r\n```ts\r\nimport resolve from 'resolve'\r\nimport { Plugin } from '../plugin'\r\nimport { ServerContext } from '../server/index'\r\nimport path from 'path'\r\nimport { pathExists } from 'fs-extra'\r\nimport { DEFAULT_EXTERSIONS } from '../constants'\r\n\r\nexport function resolvePlugin(): Plugin {\r\n  let serverContext: ServerContext\r\n  return {\r\n    name: 'm-vite:resolve',\r\n    configureServer(s) {\r\n      // 保存服务端上下文\r\n      serverContext = s\r\n    },\r\n    async resolveId(id: string, importer?: string) {\r\n      // 1. 绝对路径\r\n      if (path.isAbsolute(id)) {\r\n        if (await pathExists(id)) {\r\n          return { id }\r\n        }\r\n        // 加上 root 路径前缀，处理 /src/main.tsx 的情况\r\n        id = path.join(serverContext.root, id)\r\n        if (await pathExists(id)) {\r\n          return { id }\r\n        }\r\n      }\r\n      // 2. 相对路径\r\n      else if (id.startsWith('.')) {\r\n        if (!importer) {\r\n          throw new Error('`importer` should not be undefined')\r\n        }\r\n        const hasExtension = path.extname(id).length > 1\r\n        let resolvedId: string\r\n        // 2.1 包含文件名后缀\r\n        // 如 ./App.tsx\r\n        if (hasExtension) {\r\n          resolvedId = resolve.sync(id, { basedir: path.dirname(importer) })\r\n          if (await pathExists(resolvedId)) {\r\n            return { id }\r\n          }\r\n        }\r\n        // 2.2 不包含文件名后缀\r\n        // 如 ./App\r\n        else {\r\n          // ./App -> ./App.tsx\r\n          for (const extname of DEFAULT_EXTERSIONS) {\r\n            try {\r\n              const withExtension = `${id}${extname}`\r\n              resolvedId = resolve.sync(withExtension, {\r\n                basedir: path.dirname(importer),\r\n              })\r\n              if (await pathExists(resolvedId)) {\r\n                return { id: withExtension }\r\n              }\r\n            } catch (e) {\r\n              continue\r\n            }\r\n          }\r\n        }\r\n      }\r\n      return null\r\n    },\r\n  }\r\n}\r\n\r\n```\r\n\r\nok我们先补充一下缺少的常量:\r\n\r\nsrc/node/constants.ts\r\n\r\n```\r\nexport const DEFAULT_EXTERSIONS = [\\\".tsx\\\", \\\".ts\\\", \\\".jsx\\\", \\\"js\\\"];\r\n```\r\n\r\nok，然后`/src/main.tsx`就可以被解析成真实路径拉，模块在接下来的 `load` 钩子中能够正常加载。ok加载完路径了接下来该干嘛呢，当然是读取文件的内容拉，`tsx`浏览器是没法识别的，我们要把文件编译成js语法，这时候我们可以使用`esbuild`的`transform`拉。\r\n\r\n## Esbuild 语法编译插件\r\n\r\n这个插件的作用比较好理解，就是将 JS/TS/JSX/TSX 编译成浏览器可以识别的 JS 语法，我们直接新建`src/node/plugins/esbuild.ts`文件，内容如下:\r\n\r\nsrc/node/plugins/esbuild.ts\r\n\r\n\r\n```ts\r\nimport { readFile } from 'fs-extra'\r\nimport { Plugin } from '../plugin'\r\nimport { isJSRequest } from '../utils'\r\nimport esbuild from 'esbuild'\r\nimport path from 'path'\r\n\r\nexport function esbuildTransformPlugin(): Plugin {\r\n  return {\r\n    name: 'm-vite:esbuild-transform',\r\n    // 加载模块\r\n    async load(id) {\r\n      if (isJSRequest(id)) {\r\n        try {\r\n          const code = await readFile(id, 'utf-8')\r\n          return code\r\n        } catch (e) {\r\n          return null\r\n        }\r\n      }\r\n    },\r\n    async transform(code, id) {\r\n      if (isJSRequest(id)) {\r\n        const extname = path.extname(id).slice(1)\r\n        const { code: transformedCode, map } = await esbuild.transform(code, {\r\n          target: 'esnext',\r\n          format: 'esm',\r\n          sourcemap: true,\r\n          loader: extname as 'js' | 'ts' | 'jsx' | 'tsx',\r\n        })\r\n        return {\r\n          code: transformedCode,\r\n          map,\r\n        }\r\n      }\r\n      return null\r\n    },\r\n  }\r\n}\r\n\r\n```\r\n> 搞定了哇，在将 TSX 转换为浏览器可以识别的语法之后，是不是就可以直接返回给浏览器执行了呢？如果你觉得可以的话那我必须要骂你一声扑街了，别忘了我们上一章学的依赖预构建啊，如果tsx文件有里面第三方依赖路径(bare import)，需要重写为预构建产物路径引用产物。而且对于绝对路径和相对路径，需要借助之前的路径解析插件进行解析。ok那我们需要写一个import的分析插件。\r\n\r\n## import分析插件\r\n\r\nok我们新建`src/node/plugins/importAnalysis.ts`插件文件\r\n\r\nsrc/node/plugins/importAnalysis.ts\r\n\r\n\r\n```ts\r\nimport { init, parse } from 'es-module-lexer'\r\nimport { BARE_IMPORT_RE, PRE_BUNDLE_DIR } from '../constants'\r\nimport { isJSRequest, normalizePath } from '../utils'\r\n// magic-string 用来作字符串编辑\r\nimport MagicString from 'magic-string'\r\nimport path from 'path'\r\nimport { Plugin } from '../plugin'\r\nimport { ServerContext } from '../server/index'\r\nimport type { PluginContext } from 'rollup'\r\n\r\nexport function importAnalysisPlugin(): Plugin {\r\n  let serverContext: ServerContext\r\n  return {\r\n    name: 'm-vite:import-analysis',\r\n    configureServer(s) {\r\n      // 保存服务端上下文\r\n      serverContext = s\r\n    },\r\n    async transform(this: PluginContext, code: string, id: string) {\r\n      // 只处理 JS 相关的请求\r\n      if (!isJSRequest(id)) {\r\n        return null\r\n      }\r\n      await init\r\n      // 解析 import 语句\r\n      const [imports] = parse(code)\r\n      const ms = new MagicString(code)\r\n      // 对每一个 import 语句依次进行分析\r\n      for (const importInfo of imports) {\r\n        // 举例说明: const str = `import React from 'react'`\r\n        // str.slice(s, e) => 'react'\r\n        const { s: modStart, e: modEnd, n: modSource } = importInfo\r\n        if (!modSource) continue\r\n        // 第三方库: 路径重写到预构建产物的路径\r\n        if (BARE_IMPORT_RE.test(modSource)) {\r\n          // const bundlePath = path.join(\r\n          //   serverContext.root,\r\n          //   PRE_BUNDLE_DIR,\r\n          //   `${modSource}.js`\r\n          // )\r\n          const bundlePath = normalizePath(\r\n            path.join('/', PRE_BUNDLE_DIR, `${modSource}.js`)\r\n          )\r\n          ms.overwrite(modStart, modEnd, bundlePath)\r\n        } else if (modSource.startsWith('.') || modSource.startsWith('/')) {\r\n          // 直接调用插件上下文的 resolve 方法，会自动经过路径解析插件的处理\r\n          const resolved = await this.resolve(modSource, id)\r\n          if (resolved) {\r\n            ms.overwrite(modStart, modEnd, resolved.id)\r\n          }\r\n        }\r\n      }\r\n\r\n      return {\r\n        code: ms.toString(),\r\n        // 生成 SourceMap\r\n        map: ms.generateMap(),\r\n      }\r\n    },\r\n  }\r\n}\r\n\r\n```\r\n\r\nok,我们便完成了 JS 代码的 `import` 分析工作。接下来，我们把上面实现的三个插件进行注册,就是刚才的`resolvePlugins`函数拉。\r\n\r\nsrc/node/plugin/index.ts\r\n```\r\n// src/node/plugin/index.ts\r\nimport { esbuildTransformPlugin } from \\\"./esbuild\\\";\r\nimport { importAnalysisPlugin } from \\\"./importAnalysis\\\";\r\nimport { resolvePlugin } from \\\"./resolve\\\";\r\nimport { Plugin } from \\\"../plugin\\\";\r\n\r\nexport function resolvePlugins(): Plugin[] {\r\n  return [resolvePlugin(), esbuildTransformPlugin(), importAnalysisPlugin()];\r\n}\r\n```\r\n\r\n接下来我们可以在`playground`项目下执行`pnpm dev`，，不过在执行之前要把不是`tsx`、`ts`、的文件先注释掉（比如css文件和静态资源文件，我们后面再处理）,在浏览器里面访问`http://localhost:3000`，见证奇迹的时刻到了哇,我们可以看到如下页面：\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f73d65475fa34a579349e4fab038744b~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n打开控制台看看main.tsx的内容，可以看到react和react-dom的引用都被换成与构建产物的地址了:\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/da27bc0ad8ee4b74974811bc82db4d6b~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\nok我们完成了 JS/TS/JSX/TSX 文件的编译拉，我们还差什么呢，页面页面一定是离不开css的对吧，我们的demo项目中的css代码是这样引入的：\r\n\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8f90cbac84094d31a20c348d0072efd7~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n但是浏览器没法识别这样的语法哇，我们需要将这个模块包装成浏览器可以识别的模块才行的哇，也就是js模块拉，其中模块加载和转换的逻辑我们可以通过插件来实现。当然，首先我们需要在 `transform` 中间件中允许对 CSS 的请求进行处理，内容如下:\r\n\r\nsrc/node/server/middlewares/transform.ts\r\n\r\n```\r\n// 需要增加的导入语句\r\n+ import { isCSSRequest } from '../../utils';\r\n\r\nexport function transformMiddleware(\r\n  serverContext: ServerContext\r\n): NextHandleFunction {\r\n  return async (req, res, next) => {\r\n    if (req.method !== \\\"GET\\\" || !req.url) {\r\n      return next();\r\n    }\r\n    const url = req.url;\r\n    debug(\\\"transformMiddleware: %s\\\", url);\r\n    // transform JS request\r\n-    if (isJSRequest(url)) {\r\n+    if (isJSRequest(url) || isCSSRequest(url)) {\r\n      // 后续代码省略\r\n     }\r\n\r\n    next();\r\n  };\r\n}\r\n```\r\nok接下来我们来补充对应的工具函数:\r\n\r\n\r\n```\r\n// src/node/utils.ts\r\nexport const isCSSRequest = (id: string): boolean =>\r\n  cleanUrl(id).endsWith(\\\".css\\\");\r\n```\r\n\r\n## CSS编译插件\r\n\r\nok我们接下来要开发 `CSS` 的编译插件，没有css可不行，界面太丑了，我们直接新建一个`src/node/plugins/css.ts`文件，内容如下:\r\n\r\nsrc/node/plugins/css.ts\r\n\r\n\r\n```ts\r\n\r\nimport { readFile } from \\\"fs-extra\\\";\r\nimport { Plugin } from \\\"../plugin\\\";\r\n\r\nexport function cssPlugin(): Plugin {\r\n  return {\r\n    name: \\\"m-vite:css\\\",\r\n    load(id) {\r\n      // 加载\r\n      if (id.endsWith(\\\".css\\\")) {\r\n        return readFile(id, \\\"utf-8\\\");\r\n      }\r\n    },\r\n    // 转换逻辑\r\n    async transform(code, id) {\r\n      if (id.endsWith(\\\".css\\\")) {\r\n        // 包装成 JS 模块\r\n        const jsContent = `\r\nconst css = '${code.replace(/\\\\r\\\r\n/g, \\\"\\\")}';\r\nconst style = document.createElement(\\\"style\\\");\r\nstyle.setAttribute(\\\"type\\\", \\\"text/css\\\");\r\nstyle.innerHTML = css;\r\ndocument.head.appendChild(style);\r\nexport default css;\r\n`.trim();\r\n        return {\r\n          code: jsContent,\r\n        };\r\n      }\r\n      return null;\r\n    },\r\n  };\r\n}\r\n\r\n```\r\n这个插件的逻辑比较简单，主要是将封装一层 `JS` 模板代码，将`CSS` 包装成一个 `ES` 模块，当浏览器执行这个模块的时候，会创建`styl`e标签将`CSS`文件字符串的内容给搞到标签里去，然后就可以在页面中生效了。\r\n\r\n接着我们来注册这个 CSS 插件:\r\n\r\nsrc/node/plugins/index.ts\r\n```\r\nimport { esbuildTransformPlugin } from \\\"./esbuild\\\";\r\nimport { resolvePlugin } from \\\"./resolve\\\";\r\nimport { importAnalysisPlugin } from \\\"./importAnalysis\\\";\r\nimport { cssPlugin } from \\\"./css\\\";\r\nimport { Plugin } from \\\"../plugin\\\";\r\n\r\nexport function resolvePlugins(): Plugin[] {\r\n  return [\r\n    resolvePlugin(),\r\n    esbuildTransformPlugin(),\r\n    importAnalysisPlugin(),\r\n    cssPlugin(),\r\n  ];\r\n}\r\n\r\n```\r\n\r\n现在，我们通过`pnpm dev`来启动 `playground` 项目，在`tsx`将`css`文引入(之前是注释掉的),ok,启动之后我们可以看到一个好看的界面，乱杀之前那个：\r\n\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a2af5de4b2b641f39c6abb567c54af38~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n大家这时候可能会说了：诶，好像少了个`react`的图标哇，没有灵魂了，不好看了，心情不好了，不想再看了，难受。别急，接下来我们就来实现静态资源的加载，让大大的`react`图标出来哈。\r\n\r\n## 静态资源加载插件\r\n\r\n我们先来看看react图标在哪里哈：\r\n\r\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b622cc2b14724804820b662a78afcd66~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n站在 no-bundle 服务的角度，从如上的代码我们可以分析出静态资源的两种请求:\r\n\r\n-   import 请求。如 `import logo from \\\"./logo.svg\\\"`。\r\n-   资源内容请求。如 img 标签将资源 url 填入 src，那么浏览器会请求具体的资源内容。\r\n\r\n因此，接下来为了实现静态资源的加载，我们需要做两手准备: 对静态资源的 `import` 请求返回资源的 `url`；对于具体内容的请求，读取静态资源的文件内容，并响应给浏览器。\r\n\r\n首先处理 `import` 请求，我们可以在 `TSX` 的 `import` 分析插件中，给静态资源相关的 `import` 语句做一个标记:\r\n\r\nsrc/node/plugins/importAnalysis.ts\r\n\r\n```\r\n\r\nasync transform(code, id) {\r\n  // 省略前面的代码\r\n  for (const importInfo of imports) {\r\n    const { s: modStart, e: modEnd, n: modSource } = importInfo;\r\n    if (!modSource) continue;\r\n+    // 静态资源\r\n+    if (modSource.endsWith(\\\".svg\\\")) {\r\n+      // 加上 ?import 后缀，其他的静态资源同理\r\n+       const resolvedUrl = normalizePath(\r\n+            path.relative(\r\n+              path.dirname(id),\r\n+              path.resolve(path.dirname(id), modSource)\r\n+            )\r\n+          );\r\n+      ms.overwrite(modStart, modEnd, `./${resolvedUrl}?import`);\r\n+      continue;\r\n    }\r\n  }\r\n}\r\n```\r\nok我们看看编译后的App.tsx是什么样的: \r\n\r\n\r\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d4b3beb58d0c4f0fb3a7f5e42820fcb2~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\nok我们可以看到路径后面多了个`?import`的后缀，有这个后缀代表这是静态资源的请求，然后我们在`transform`插件里对这种请求进行处理:\r\n\r\nsrc/node/server/middlewares/transform.ts\r\n```\r\n// 需要增加的导入语句\r\n+ import { isImportRequest } from '../../utils';\r\n\r\nexport function transformMiddleware(\r\n  serverContext: ServerContext\r\n): NextHandleFunction {\r\n  return async (req, res, next) => {\r\n    if (req.method !== \\\"GET\\\" || !req.url) {\r\n      return next();\r\n    }\r\n    const url = req.url;\r\n    debug(\\\"transformMiddleware: %s\\\", url);\r\n    // transform JS request\r\n-    if (isJSRequest(url) || isCSSRequest(url)) {\r\n+    if (isJSRequest(url) || isCSSRequest(url) || isImportRequest(url)) {\r\n      // 后续代码省略\r\n     }\r\n\r\n    next();\r\n  };\r\n}\r\n```\r\n然后我们补充工具函数\r\n\r\nsrc/node/utils.ts\r\n```\r\nexport function isImportRequest(url: string): boolean {\r\n  return url.endsWith(\\\"?import\\\");\r\n}\r\n```\r\n\r\nok接下来我们就可以开发静态资源插件了。新建`src/node/plugins/assets.ts`，内容如下:\r\n\r\nsrc/node/plugins/assets.ts\r\n\r\n```ts\r\nimport { Plugin } from \\\"../plugin\\\";\r\nimport { cleanUrl, normalizePath, removeImportQuery } from \\\"../utils\\\";\r\n\r\nexport function assetPlugin(): Plugin {\r\n  return {\r\n    name: \\\"m-vite:asset\\\",\r\n    async load(id) {\r\n      const cleanedId = removeImportQuery(cleanUrl(normalizePath(id)));\r\n\r\n      // 这里仅处理 svg\r\n      if (cleanedId.endsWith(\\\".svg\\\")) {\r\n        return {\r\n          // 包装成一个 JS 模块\r\n          // 因为这里的window用户路径有点问题，要盘符给去掉，mac用户不用replace\r\n          // window用户的\r\n          code: `export default \\\"${cleanedId.replace(\\\"C:\\\", \\\"\\\")}\\\"`,\r\n          // mac用户的，如果是mac换成下面的代码\r\n          // code: `export default \\\"${cleanedId}\\\"`,\r\n        };\r\n      }\r\n    },\r\n  };\r\n}\r\n\r\n```\r\nok我们来注册这个插件:\r\n\r\nsrc/node/plugins/index.ts\r\n```\r\nimport { esbuildTransformPlugin } from \\\"./esbuild\\\";\r\nimport { resolvePlugin } from \\\"./resolve\\\";\r\nimport { importAnalysisPlugin } from \\\"./importAnalysis\\\";\r\nimport { cssPlugin } from \\\"./css\\\";\r\nimport { assetPlugin } from \\\"./assets\\\";\r\nimport { Plugin } from \\\"../plugin\\\";\r\n\r\nexport function resolvePlugins(): Plugin[] {\r\n  return [\r\n    resolvePlugin(),\r\n    esbuildTransformPlugin(),\r\n    importAnalysisPlugin(),\r\n    cssPlugin(),\r\n    assetPlugin(),\r\n  ];\r\n}\r\n\r\n}\r\n```\r\n\r\nOK，我们处理完了静态资源的 import 请求，接着我们还需要处理非 import 请求，返回资源的具体内容。我们可以通过一个中间件来进行处理，我们新建`src/node/server/middlewares/static.ts`这个文件，内容如下：\r\n\r\nsrc/node/server/middlewares/static.ts\r\n\r\n```\r\nimport { NextHandleFunction } from \\\"connect\\\";\r\nimport { isImportRequest } from \\\"../../utils\\\";\r\n// 一个用于加载静态资源的中间件\r\nimport sirv from \\\"sirv\\\";\r\n\r\nexport function staticMiddleware(): NextHandleFunction {\r\n  const serveFromRoot = sirv(\\\"/\\\", { dev: true });\r\n  return async (req, res, next) => {\r\n    if (!req.url) {\r\n      return;\r\n    }\r\n    // 不处理 import 请求\r\n    if (isImportRequest(req.url)) {\r\n      return;\r\n    }\r\n    serveFromRoot(req, res, next);\r\n  };\r\n}\r\n```\r\n\r\n我们在服务端中注册这个中间件:\r\n\r\nsrc/node/server/index.ts\r\n\r\n```\r\n// 需要添加的引入语句\r\n+ import { staticMiddleware } from \\\"./middlewares/static\\\";\r\n\r\nexport async function startDevServer() {\r\n  // 前面的代码省略\r\n+  app.use(staticMiddleware());\r\n\r\n  app.listen(3000, async () => {\r\n    // 省略实现\r\n  });\r\n}\r\n```\r\n\r\n在playground里执行`pnpm dev`运行项目,然后我们就可以看到大大的react图标了：\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cedd523cb875405a802fdca7ce5b6cb1~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\nok我们`mini-vite`的插件机制的开发终于搞定了,怎么样是不是干货满满呢，有问题可以找我一起讨论哇！！！\r\n\r\n## 往期文章\r\n\r\n- ### [一起写个vite吧！(1) --环境搭建+依赖预构建](https://juejin.cn/post/7154007357305913357)\r\n\r\n### [mini-vite仓库地址(里面有对应的提交记录，如果有兴趣可以拉下来跑一跑哇)](https://github.com/cjhw/mini-vite)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {   "snapshot": "",
        "title": "Mpx2.8 版本正式发布，使用组合式 API 开发小程序",
        "preview": "Mpx2.8 版本正式发布，完整支持组合式 API，让用户能够使用时下最热门且备受好评的开发方式进行小程序开发。",
        "author": "hiyuki",
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/be946dc67a0e3de8c64bc5582d928981~300x300.image",
        "content": "> 作者：[hiyuki](https://github.com/hiyuki)\r\n\r\n小程序跨端开发框架 [Mpx](https://www.mpxjs.cn/) 自18年立项开源以来，如今已经走过了第四个年头，其高性能、优体验、跨平台的特性收获了公司内外开发者用户的一致好评。\r\n\r\n为了不辜负开发者用户对我们的信赖，更好地支持集团小程序业务开发，一方面我们对 Mpx 的稳定版本进行着高频的维护迭代，快速响应处理集团内外开发者用户在框架开发使用过程中遇到的问题；另一方面我们持续跟进探索业内最新动态，力争将更新更好的开发能力与体验带给小程序开发者用户。继年初我们在 [2.7 版本](https://mpxjs.cn/guide/migrate/2.7.html)中对 Mpx 的编译系统进行重构适配 Webpack5，基于持久化缓存大幅提升编译速度后，在最新的 [2.8 版本](https://mpxjs.cn/guide/migrate/2.8.html)中，我们对 Mpx 的运行时框架也进行了大量重构改造工作，完整支持了 Vue3 提出的组合式 API 开发范式，让用户能够使用当下最热门的开发方式进行小程序开发，我们先来简单感受一下组合式 API 的使用：\r\n\r\n```html\r\n<template>\r\n  <view>{{ collectionName }}: {{ book.title }}({{ readersNumber }})</view>\r\n  <button bindtap=\\\"addReaders\\\">addReaders</button>\r\n</template>\r\n\r\n<script>\r\n  import { createComponent, ref, reactive, onMounted } from '@mpxjs/core'\r\n\r\n  createComponent({\r\n    properties: {\r\n      collectionName: String\r\n    },\r\n    setup () {\r\n      const readersNumber = ref(0)\r\n      const book = reactive({ title: 'Mpx' })\r\n\r\n      onMounted(() => {\r\n        console.log('Component mounted.')\r\n      })\r\n\r\n      // 暴露给 template\r\n      return {\r\n        readersNumber,\r\n        book,\r\n        addReaders () {\r\n          readersNumber.value++\r\n        }\r\n      }\r\n    }\r\n  })\r\n</script>\r\n```\r\n\r\n可以看出和 Vue3 组合式 API 的使用是高度类似的，利用框架导出的一系列响应式 API 和 生命周期钩子函数在 `setup` 中编写业务逻辑，并将模板依赖的数据与方法作为返回值返回，与传统的选项式 API 相比，组合式 API 具备以下优势：\r\n\r\n* 更好的逻辑复用，通过函数包装复用逻辑，显式引入调用，方便简洁且符合直觉，规避消除了 mixins 复用中存在的缺陷；\r\n* 更灵活的代码组织，相比于选项式 API 提前规定了代码的组织方式，组合式 API 在这方面几乎没有做任何限制与规定，更加灵活自由，在功能复杂的庞大组件中，我们能够通过组合式 API 让我们的功能代码更加内聚且有条理，不过这也会对开发者自身的代码规范意识提出更高要求；\r\n* 更好的类型推导，虽然基于 `this` 的选项式 API 通过 `ThisType` 类型体操的方式也能在一定程度上实现 TS 类型推导，但推导和实现成本较高，同时仍然无法完美覆盖一些复杂场景（如嵌套 mixins 等）；而组合式 API 以本地变量和函数为基础，本身就是类型友好的，我们在类型方面几乎不需要做什么额外的工作就能享受到完美的类型推导。\r\n\r\n同时与 React Hooks 相比，组合式 API 中的 `setup` 函数只在初始化时单次执行，在数据响应能力的加持下大大降低了理解与使用成本，基于以上原因，我们决定为 Mpx 添加组合式 API 能力，让用户能够用组合式 API 方式进行小程序开发。\r\n\r\n## 组合式 API 实现\r\n\r\n从上面的简单示例中可以看出，抛开响应式 API 和生命周期注册模式的变化，组合式 API 的实现要点在于动态添加模板依赖的数据和方法，这也是我们在小程序中实现组合式 API 可能遇到的核心技术卡点。\r\n\r\n对于动态添加模板依赖数据，我们在过去的实践中已经充分证明了其可行性，事实上，从 Mpx 最初的版本开始，我们就充分利用了这项能力来实现我们对计算属性和 `dataFn` （类似于 Vue 使用函数定义 `data`）的支持，这项能力的关键在于存在合适的生命周期用于动态添加初始化数据，这里对于初始化数据的定义是能够影响组件树的初始渲染，举个简单的例子：存在一对父子组件 parent/child，parent 使用 `props` 向 child 传递数据，当我们在 parent 初始创建时使用 `setData` 动态添加 `props` 数据，同时 child 在初始创建时能够通过 `props` 正确获取到这部分的数据时，我们就可以将这部分动态添加的数据视作初始化数据，这是我们在小程序中实现完备数据响应支持的基础。\r\n\r\n幸运的是，目前业内所有主流小程序平台（微信/支付宝/百度/字节/QQ）都支持了上述能力，微信从一开始就支持在 `attached` 生命周期中调用 `setData` 函数动态添加初始化数据，在上述的父子 `props` 传递场景中，也能够在子组件的 `attached` 中正确获取这部分数据，支付宝和字节小程序一开始并不支持该能力，不过支付宝在 `component2` 组件系统重构后，字节在橙心合作项目中与我们沟通后，都成功支持了该能力。\r\n\r\n而对于动态返回的方法，最简单能想到的方案就是直接挂载到组件实例上，经过我们的完整测试，上述业内主流小程序平台都支持使用这种方式动态添加方法，基于以上事实，我们非常确定组合式 API 能够在小程序环境中顺利实现，下图简要展示了 Mpx 支持组合式 API 的初始化流程：\r\n\r\n![composition-api-init](https://dpubstatic.udache.com/static/dpubimg/0bxxw8bB9PJxXLeiMQ__6_composition-api-init.png)\r\n\r\n\r\n### 生命周期钩子函数\r\n\r\n在组合式 API 中，`setup` 函数只有在组件创建时初始化单次执行，因此需要提供一系列生命周期钩子函数来代替选项式 API 中的生命周期钩子选项，由于小程序原生只支持选项式的生命周期注册方式，我们通过`预注册 -> 驱动`的方式来实现 `setup` 中函数式注册生命周期钩子的语法糖，简单来讲就是使用选项式 `mixins` 的方式提前注册所有需要的生命周期钩子，在选项式生命周期钩子执行时驱动对应在 `setup` 中使用生命周期钩子函数注册的代码逻辑执行，如下图所示：\r\n\r\n![composition-api-hook](https://dpubstatic.udache.com/static/dpubimg/2nmOjxvubyk6H32yP5cFc_composition-api-hook.png)\r\n\r\n作为跨端小程序框架，Mpx 需要兼容不同小程序平台不同的生命周期，在选项式 API 中，我们在框架中内置了一套统一的生命周期，将不同小程序平台的生命周期转换映射为内置生命周期后再进行统一的驱动，以抹平不同小程序平台生命周期钩子的差异，如微信小程序的 `attached` 钩子和支付宝小程序的 `onInit` 钩子，在组合式 API 中，我们沿用了同样的逻辑，设计了一套与框架内置生命周期对应的生命周期钩子函数，以相同的方式进行驱动，因此这些生命周期钩子函数天然具备了跨平台特性，下表显示了在组件 / 页面中框架生命周期与原生平台生命周期的对应关系：\r\n\r\n|框架内置生命周期|Hooks in `setup`|微信原生|支付宝原生|\r\n|:------------|:------------------|:-----|:-------|\r\n| BEFORECREATE | `null` |attached（数据响应初始化前）|onInit（数据响应初始化前）|\r\n| CREATED | `null` |attached（数据响应初始化后）|onInit（数据响应初始化后）|\r\n| BEFOREMOUNT | onBeforeMount |ready（`MOUNTED` 执行前）|didMount（`MOUNTED` 执行前）| \r\n| MOUNTED | onMounted |ready（`BEFOREMOUNT` 执行后）|didMount（`BEFOREMOUNT` 执行后）| \r\n| BEFOREUPDATE | onBeforeUpdate |`null`（`setData` 执行前）|`null`（`setData` 执行前）|\r\n| UPDATED | onUpdated |`null`（`setData` callback）|`null`（`setData` callback）|\r\n| BEFOREUNMOUNT | onBeforeUnmount |detached（数据响应销毁前）|didUnmount（数据响应销毁前）|\r\n| UNMOUNTED | onUnmounted |detached（数据响应销毁后）|didUnmount（数据响应销毁后）|\r\n| ONLOAD | onLoad |onLoad|onLoad|\r\n| ONSHOW | onShow |onShow|onShow|\r\n| ONHIDE | onHide |onHide|onHide|\r\n| ONRESIZE | onResize |onResize|events.onResize|\r\n\r\n> 同 Vue3 一样，Mpx 在组合式 API 中没有提供 `BEFORECREATE` 和 `CREATED` 对应的生命周期钩子函数，用户可以直接在 `setup` 中编写相关逻辑。\r\n\r\n#### 具有副作用的页面事件\r\n\r\n在小程序中，一些页面事件的注册存在副作用，即该页面事件注册与否会产生实质性的影响，比如微信中的 `onShareAppMessage` 和 `onPageScroll`，前者在不注册时会禁用当前页面的分享功能，而后者在注册时会带来视图与逻辑层之间的线程通信开销，对于这部分页面事件，我们无法通过`预注册 -> 驱动`方式提供组合式 API 的注册方式，用户可以通过选项式 API 的方式来注册使用，通过 `this` 访问组合式 API `setup` 函数的返回。\r\n\r\n然而这种使用方式显然不够优雅，我们考虑是否可以通过一些非常规的方式提供这类副作用页面事件的组合式 API 注册支持，例如，借助编译手段。我们在运行时提供了副作用页面事件的注册函数，并在编译时通过 `babel` 插件的方式解析识别到当前页面中存在这些特殊注册函数的调用时，通过框架已有的`编译 -> 运行时注入`的方式将事件驱动逻辑添加到当前页面当中，以提供相对优雅的副作用页面事件在组合式 API 中的注册方式，同时不产生非预期的副作用影响，简单示例如下：\r\n\r\n```js\r\nimport { createPage, ref, onShareAppMessage } from '@mpxjs/core'\r\n\r\ncreatePage({\r\n  setup () {\r\n    const count = ref(0)\r\n\r\n    onShareAppMessage(() => {\r\n      return {\r\n        title: '页面分享'\r\n      }\r\n    })\r\n\r\n    return {\r\n      count\r\n    }\r\n  }\r\n})\r\n```\r\n\r\n目前我们通过这种方式支持的页面事件如下：\r\n\r\n| 页面事件 | Hooks in `setup` | 平台支持 |\r\n|:------------|:------------------|:-----|\r\n| onPullDownRefresh | onPullDownRefresh | 全小程序平台 + web |\r\n| onReachBottom | onReachBottom | 全小程序平台 + web |\r\n| onPageScroll | onPageScroll | 全小程序平台 + web |\r\n| onShareAppMessage | onShareAppMessage | 全小程序平台 |\r\n| onTabItemTap | onTabItemTap | 微信/支付宝/百度/QQ |\r\n| onAddToFavorites | onAddToFavorites | 微信 / QQ |\r\n| onShareTimeline | onShareTimeline | 微信 |\r\n| onSaveExitState | onSaveExitState | 微信 |\r\n\r\n> **特别注意**，由于静态编译分析实现方式的限制，这类页面事件的组合式 API 使用需要满足页面事件注册函数（如`onShareAppMessage`）的调用和 `createPage` 的调用位于同一个 js 文件当中。\r\n\r\n关于生命周期钩子函数的更多信息可以查看[这里](https://mpxjs.cn/guide/composition-api/composition-api.html#lifecycle-hooks)。\r\n\r\n### `<script setup>`\r\n\r\n同 Vue3 一样，我们在 `.mpx` 单文件组件 / 页面中实现了 `<script setup>` 的组合式 API 编译语法糖，相较于常规的写法，`<script setup>` 具备以下优势：\r\n\r\n* 更少的样板内容，更简洁的代码\r\n* 能够使用纯 TypeScript 声明 props 类型\r\n* 更好的 IDE 类型推导性能\r\n\r\n简单使用示例如下：\r\n\r\n```html\r\n<script setup>\r\n  import { ref } from '@mpxjs/core'\r\n\r\n  const msg = ref('hello')\r\n\r\n  function log () {\r\n    console.log(msg.value)\r\n  }\r\n</script>\r\n<template>\r\n  <view>msg: {{msg}}</view>\r\n  <view ontap=\\\"log\\\">click</view>\r\n</template>\r\n```\r\n\r\n可以看到使用方式与 Vue3 基本一致，不过由于 Mpx 的组合式 API 设计实现与 Vue3 存在差异，对应 `<script setup>` 也与 Vue3 中存在一些差异：\r\n\r\n* 不支持 `import` 快捷注册组件\r\n* 没有 `defineEmits()` 编译宏\r\n* 没有 `useSlots()` 和 `useAttrs()` 运行时函数\r\n* 以编译宏的形式提供了 `useContext()`，获取 `setup` 函数的第二个参数 `context`\r\n* `defineExpose()` 编译宏的作用与 Vue3 中有所差别，能够限定模板中能访问的变量范围\r\n\r\n> **特别注意**，受小程序底层技术限制，我们在 Mpx 的实现中无法像 Vue3 那样将模板编译的渲染函数和 `<script setup>` 放置到同一作用域下进行变量访问，而是通过静态编译分析提取出 `<script setup>` 的顶层作用域变量，再以上文中提到的动态添加数据与方法的方式将其设置到模板当中，如果 `<script setup>` 中声明了较多顶层作用域变量，它们并不一定都会被模板访问，就会带来无效的性能开销，因此我们强烈建议使用 `defineExpose()` 限定模板中能访问的变量范围，你可以把它等同于 `setup` 函数中的 `return`。\r\n\r\n关于 `<script setup>` 的更多信息可以查看[这里](https://mpxjs.cn/guide/composition-api/composition-api.html#script-setup)。\r\n\r\n### 组合式 API 与 Vue3 中的差异\r\n\r\n我们来总结一下 Mpx 中组合式 API 与 Vue3 中的区别：\r\n\r\n* `setup` 的 `context` 参数不同，详见[这里](https://mpxjs.cn/guide/composition-api/composition-api.html#context)\r\n* `setup` 不支持返回**渲染函数**\r\n* `setup` 不能是异步函数\r\n* `<script setup>` 提供的宏方法不同，详见[这里](https://mpxjs.cn/guide/composition-api/composition-api.html#script-setup)\r\n* `<script setup>` 不支持 `import` 快捷注册组件\r\n* 支持的生命周期钩子不同，详见[这里](https://mpxjs.cn/guide/composition-api/composition-api.html#lifecycle-hooks)\r\n* 模板引用的方式不同，详见[这里](https://mpxjs.cn/guide/composition-api/composition-api.html#template-ref)\r\n\r\n关于组合式 API 的更多信息可以查看[这里](https://mpxjs.cn/guide/composition-api/composition-api.html)。\r\n\r\n## 响应式 API 实现\r\n\r\n组合式 API 的正常工作离不开响应式 API 的支持，下面我们来聊聊 Mpx 中响应式 API 的设计实现。我们知道 Vue3 中响应式 API 基于 `proxy` 进行了重构实现，但是目前 `proxy` 的浏览器兼容占比仍然无法达到我们对于线上可用性的要求，因此在 Mpx 中，我们仍然基于 `Object.defineProperty` 进行核心数据响应能力的实现，同时借鉴了 Vue3 中优秀的代码设计与实现，如 `reactiveEffect` 和 `effectScope` 等，尽可能实现与 Vue3 中响应式 API 能力对齐。\r\n\r\n说到这里，很多同学可能会想到 `@vue/composition-api` 这个库，该库提供的关键能力正是基于 Vue2 的数据响应系统模拟实现 Vue3 中的响应式 API，我们在前期也对 `@vue/composition-api` 在 Mpx 中的复用进行了非常有价值的探索尝试。不过最终我们还是决定在 Mpx 的运行时框架中进行独立实现，原因主要在于：`@vue/composition-api` 是作为一个 Vue2 插件存在，无法直接侵入 Vue2 源码，导致部分能力无法实现或会带来额外的性能开销，例如 `flush: 'post'` 和 `ref` 自动解包等。我们也看到在最新的 Vue2.7 版本中，也是在运行时框架里重新实现了这部分内容，以规避上述问题。\r\n\r\n下图展示了 Mpx 中响应式 API 核心模块依赖关系：\r\n\r\n![composition-api-reactive](https://dpubstatic.udache.com/static/dpubimg/4ySdEqTRhc_DRWWCJWrhJ_composition-api-reactive.png)\r\n\r\n### 数据响应限制带来的差异\r\n\r\n由于 `Object.defineProperty` 的能力限制，Mpx 存在和 Vue2 一致的数据响应限制，无法感知到对象 property 的添加和删除以及数组的索引赋值，与 Vue2 一致，我们暴露了 `set` 和 `del` API 来让用户显式地进行相关操作。除此之外，由于使用方式发生了变化，我们在使用 `reactive` API 创建响应式数据时，还会遇到新的限制，我们来看一下代码示例：\r\n\r\n```js\r\nimport { reactive, watchSyncEffect, set } from '@mpxjs/core'\r\n\r\nconst state = reactive([0, 1, 2, 3])\r\n\r\nwatchSyncEffect(() => {\r\n  console.log(JSON.stringify(state)) // [0,1,2,3]\r\n})\r\n\r\nset(state, 1, 3) // 不会触发 watchEffect\r\n\r\nstate.push(4) // 不会触发 watchEffect\r\n```\r\n\r\n可以看出，即使我们使用了 `set` API 和数组原型方法对数组进行修改，我们仍然无法监听到数据变化。\r\n\r\n> 相同的限制在使用 `Object.defineProperty` 的 Vue2.7 中也同样存在。\r\n\r\n为什么会存在这个限制呢？原因在于：基于 `Object.defineProperty` 实现的数据响应系统中，我们会对对象的每个已有属性创建了一个 `Dep` 对象，在对该属性进行 `get` 访问时通过这个对象将其与依赖它的观察者 `ReactiveEffect` 关联起来，并在 `set` 操作时触发关联 `ReactiveEffect` 的更新，这是我们大家都知道的数据响应的基本原理。但是对于新增/删除对象属性和修改数组的场景，我们无法事先定义当前不存在属性的 `get/set` (当然这在 `proxy` 当中是可行的)，因此我们会把对象或者数组本身作为一个数据依赖创建 `Dep` 对象，**通过父级访问**该数据时定义的 `get/set` 将其关联到对应的 `ReactiveEffect`，并在对数据进行新增/删除属性或数组操作时通过数据本身持有的 `Dep` 对象触发关联 `ReactiveEffect` 的更新，如下图所示：\r\n\r\n![数据响应原理](https://dpubstatic.udache.com/static/dpubimg/XkI9cQBsLy_7np-T3rt56_composition-api-reactive2.png)\r\n\r\n需要注意的是，**通过父级访问**是建立 `Dep` 与 `ReactiveEffect` 关联关系的先决条件，在选项式 API 中，我们访问组件的响应式数据都需要通过 `this` 进行访问，相当于这些数据都存在 `this` 这个必要的**父级**，因此我们在使用 `$set/$delete` 进行对对象进行新增/删除属性或对数组进行修改时都能得到符合预期的结果，唯一的限制在于不能新增/删除根级数据属性，原因就在于 `this` 不存在访问它的父级。\r\n\r\n但是在组合式 API 中，我们不需要通过 `this` 访问响应式数据，因此通过 `reactive()` 创建的响应式数据本身就是根级数据，我们自然无法通过上述方式感知到根级数据自身的变化（在 Vue3 中，基于 `proxy` 提供的强大能力响应式系统能够精确地感知到数据属性，甚至是当前不存在属性的访问与修改，不需要为数据自身建立 `Dep` 对象，自然也不存在相关问题）。\r\n\r\n在这种情况下，我们就需要用 `ref()` 创建响应式数据，因为 `ref` 创建了一个包装对象，我们永远需要通过 `.value` 来访问其持有的数据（不管是显式访问还是隐式自动解包），这样就能保证 `ref` 数据自身的变化能够被响应式系统感知，因此也不会遇到上面描述的问题，如下所示：\r\n\r\n```js\r\nimport { ref, watchSyncEffect, set } from '@mpxjs/core'\r\n\r\nconst state = ref([0, 1, 2, 3])\r\n\r\nwatchSyncEffect(() => {\r\n  console.log(JSON.stringify(state.value)) // [0,1,2,3]\r\n})\r\n\r\nset(state.value, 1, 3) // [0,3,2,3]\r\n\r\nstate.value.push(4) // [0,3,2,3,4]\r\n```\r\n\r\n### 响应式 API 与 Vue3 中的区别\r\n\r\n我们来总结一下 Mpx 中响应式 API 与 Vue3 中的区别：\r\n\r\n* 不支持 `raw` 相关 API（`markRaw` 除外，我们提供了该 API 用于跳过部分数据的响应式转换）\r\n* 不支持 `readonly` 相关 API\r\n* 不支持 `watchEffect`、`watch`、`computed` 的调试选项\r\n* 不支持对 `map`、`set` 等集合类型进行响应式转换\r\n* 受到 `Object.defineProperty` 实现带来的数据响应限制影响\r\n\r\n关于响应式 API 的更多信息可以查看[这里](https://mpxjs.cn/guide/composition-api/reactive-api.html)。\r\n\r\n## 生态周边适配\r\n\r\n除了 Mpx 运行时核心提供了组合式 API 支持外，我们对 Mpx 的周边生态能力也都进行了组合式 API 适配支持，包括 `store`、`i18n`、`fetch` 等。\r\n\r\n### Pinia store 支持\r\n\r\nPinia 是基于组合式 API 设计的全新数据管理方案，目前已经取代 Vuex 成为 Vue3 官方推荐的 store，我们在研究了 pinia 的设计实现后，对其简练优雅的设计思想及其与组合式 API 的高度适配非常满意（特别是在使用 `setup` 函数创建 store 时，使用心智与编写组件完全一致，可以将其视作是没有视图的组件）。因此我们 fork 了 pinia 的源码仓库，基于 Mpx 提供的数据响应能力对其进行了适配改造，使其在 Mpx 环境下也能正常运行，目前相关代码维护在 `@mpxjs/pinia` 中，在组合式 API 中的简单使用示例如下：\r\n\r\n```js\r\nimport { createComponent, ref, computed, toRefs } from '@mpxjs/core'\r\nimport { defineStore } from '@mpxjs/pinia'\r\n\r\n// 使用组合式 API 创建 pinia store 的使用心智与 setup 函数完全一致，强烈推荐\r\nconst useSetupStore = defineStore('setup', () => {\r\n  const count = ref(0)\r\n  const doubleCount = computed(() => count.value * 2)\r\n\r\n  function increment () {\r\n    count.value++\r\n  }\r\n\r\n  return { count, doubleCount, increment }\r\n})\r\n\r\ncreateComponent({\r\n  setup () {\r\n    const store = useSetupStore()\r\n    // store 同 props 类似是一个 reactive 对象，解构数据需使用 toRefs 以保持数据响应性\r\n    const { count, doubleCount } = toRefs(store)\r\n    // 方法可以直接解构\r\n    const { increment } = store\r\n  \r\n    return { count, doubleCount, increment }\r\n    //\r\n  }\r\n})\r\n```\r\n\r\nMpx 中通过 `createStore` 创建的类 Vuex store 在组合式 API 中仍然可以使用，我们可以在 `setup` 函数中引用 store 实例进行[数据读取与方法调用](https://mpxjs.cn/guide/advance/store.html#use-store-in-composition-api)，不过整体使用体验与 pinia store 存在较大差距，我们还是推荐在组合式 API 开发中优先使用 pinia store 作为数据管理方案。\r\n\r\n### I18n 支持\r\n\r\n传统选项式 API 中，我们使用 `this.$t` 方法在组件内调用翻译函数，但在组合式 API 中我们无法访问 `this`，为此我们参考了 Vue I18n 最新的 9.x 版本，该版本针对 Vue3 及组合式 API 进行了重构适配，提供了全新的 `useI18n` API，简单使用示例如下：\r\n\r\n```html\r\n<template>\r\n  <view>{{t('message.hello')}}</view>\r\n  <button bindtap=\\\"changeLocale\\\">change locale</button>\r\n</template>\r\n\r\n<script>\r\n  import { createComponent, useI18n } from '@mpxjs/core'\r\n\r\n  createComponent({\r\n    setup () {\r\n      // useI18n 不传参数时指向全局 i18n 对象，也可以传递 locale 和 messages 配置创建局部 i18n 对象\r\n      const { t, locale } = useI18n()\r\n\r\n      function changeLocale () {\r\n        locale.value = locale.value === 'zh-CN' ? 'en-US' : 'zh-CN'\r\n      }\r\n      // 返回的翻译方法名必须为 t，不能进行重命名\r\n      return { t, changeLocale }\r\n    }\r\n  })\r\n</script>\r\n```\r\n\r\n> 上面示例代码看上去像是我们在模板上直接调用 setup() 返回的 t 翻译方法，但是熟悉小程序开发的同学都知道在小程序架构下这是不可能的，示例中的写法其实由框架通过编译 + 运行时手段实现的语法糖，我们会在模板编译时定向扫描 t/te/tm 等 i18n 方法，将其转换为计算属性注入到运行时当中，这就意味着如果我们对翻译方法进行重命名，模板编译时无法识别出 i18n 方法调用，自然也就无法正常运行。\r\n\r\nMpx 中 i18n 提供了两种实现模式，分别是 wxs 和 computed，可以使用编译选项中的 `i18n.isComputed` 进行切换，两种方式各有优劣，其中：\r\n* wxs 模式的优势在于逻辑层和视图层独立维护语言集，无额外运行时性能开销，且使用没有任何限制；劣势同样源于语言集同时存在于逻辑层（js）和视图层（wxs）当中，这部分的包体积占用翻倍；\r\n* computed 模式的优势在于语言集只存在于逻辑层中，无额外包体积占用，且可以通过动态添加语言集的方式进一步减少包体积占用；劣势则是会产生额外的运行时性能开销，且使用上存在限制，模板调用时无法直接访问 `wx:for` 中的 `item` 和 `index`。\r\n\r\n在组合式 API 中模板上使用 `useI18n()` 返回的翻译函数 `t/te/tm` 时，为了完整实现 `useI18n` API的功能，会强制使用 computed 模式进行实现，这也意味着该用法会受到 computed 模式使用限制的影响。不过当你不需要使用 `useI18n` 接受 `messages` 参数创建局部语言集作用域功能时，你也完全可以在模板中继续使用原有的 `$t/$tc/$te/$tm` 方法，这些方法受编译选项 `i18n.isComputed` 的影响，同时指向全局语言集作用域。\r\n\r\n更多关于生态周边的组合式 API 使用指南可以点击下方链接查看详情：\r\n\r\n* [store](https://mpxjs.cn/guide/advance/store.html#use-store-in-composition-api)\r\n* [i18n](https://mpxjs.cn/guide/advance/i18n.html#composition-api-usage)\r\n* [fetch](https://mpxjs.cn/guide/extend/fetch.html#composition-api-usage)\r\n\r\n## 输出 web 适配\r\n\r\n跨端输出 web 作为 Mpx 的一大核心特性，在业务中存在广泛使用，同时也是我们设计实现任何框架新特性需要优先考虑的事项。在本次组合式 API 支持中，我们从设计之初就考虑了跨端输出 web 的适配支持，保障使用 Mpx 组合式 API 开发的业务代码都能在 web 环境中正常运行。\r\n\r\n我们输出 web 的整体技术方向在于尽可能复用 Vue 已有的生态能力，为了实现这个目标，我们需要提供尽可能与 Vue 保持一致的 API 设计，以降低抹平适配成本。在输出 web 时，核心组合式 API 基于 Vue2.7 版本中的已有能力进行适配提供，简单举个例子：对于 `import { ref } from 'mpxjs/core'` 这行语句，在小程序中会指向 Mpx 内部维护的 `ref` 实现，而在输出 web 时会指向 Vue 中维护的 `ref` 实现，两者的实现虽然不仅相同，但只要保障对外函数签名一致，对于开发者用户来说就无感知。\r\n\r\n我们借助了 Mpx 强大的条件编译能力进行上述实现，对运行时导出根据输出平台进行重定向，这样还能保障跨端输出产物干净简洁，仅包含当前输出环境下必要的逻辑，如下图所示：\r\n\r\n![composition-api-web](https://dpubstatic.udache.com/static/dpubimg/E0FojaPKOxZOa5h5OEPQk_composition-api-web.png)\r\n\r\n同理，我们也采用了类似的方式实现了组合式 API 周边能力对于输出 web 的适配支持，如pinia store 使用 pinia 原始版本进行适配实现，而 i18n 能力则是使用 vue-i18n@8.x + vue-i18n-bridge 进行适配实现。\r\n\r\n\r\n## 性能表现\r\n\r\n性能是 Mpx 一直以来的核心关注点，我们对组合式 API 的最终实现版本进行了一系列性能评估测试，我们使用组合式 API 版本对业务中的评价组件进行了重构，评价组件属于我们业务中交互及功能相对比较复杂的组件，源码行数约 1000 行，组件数据 27 项，组件方法 18 个，我们在测试项目中对选项式 API 和组合式 API 两个版本实现的组件进行了一系列测试。\r\n\r\n### 组件初始化耗时\r\n\r\n由于组合式 API 改变了原有的组件初始化流程，我们对组件的初始化耗时进行了重点测试，测试口径如下：\r\n\r\n* 耗时计算以挂载组件为起点，以组件 `ready` 执行为终点\r\n* 测试结果为10次手工测试排除最大最小值后求均值\r\n* IOS 测试机型为 iPhone 13 pro max，安卓测试机型为 OPPO R9\r\n\r\n结果显示两个版本的组件初始化耗时大抵持平，不分优劣。\r\n\r\n|    |IOS  |安卓  |\r\n|----|-----|-----|\r\n|选项式 API|42.5ms|366.6ms|\r\n|组合式 API|42.4ms|370.1ms|\r\n\r\n\r\n### 组件 JS 体积\r\n\r\n在构建产物体积方面，由于组合式 API 的写法对于 JS 代码压缩更加有利，同样的逻辑实现下，组合式 API 版本的组件构建压缩后 JS 体积略胜一筹。\r\n\r\n|    |组件 JS 体积|\r\n|----|-----|\r\n|选项式 API|15.67KB|\r\n|组合式 API|13.60KB|\r\n\r\n### 框架运行时体积\r\n\r\n在 Mpx2.8 版本中，我们在框架运行时中新增了组合式 API 相关实现，不过通过优化运行时导出，使其对 tree shaking 更加友好，我们的框架运行时体积在实际构建产物中没有产生太大增长。\r\n\r\n|    |框架运行时体积|\r\n|----|-----|\r\n|选项式 API|51.66KB|\r\n|组合式 API|57.47KB|\r\n\r\n\r\n综上所述，组合式 API 版本的运行时性能与选项式 API 大抵持平，在包体积占用方面，新版框架运行时体积占用略有提升，不过由于组合式 API 开发模式对代码压缩更友好，加上组合式 API 更易进行逻辑复用的特点，我们预计在实际业务项目中，组合式 API 的包体积占用会更小。\r\n\r\n## 破坏性改变\r\n\r\nMpx 组合式 API 版本完全兼容原有的选项式 API 开发方式，不过我们在运行时重构过程中依然带来了少量的破坏性改变，详情如下：\r\n\r\n* 框架过往提供的组件增强生命周期 `pageShow/pageHide` 与微信原生提供的 `pageLifetimes.show/hide` 完全对齐，不再提供组件初始挂载时必定执行 `pageShow` 的保障（因为组件可能在后台页面进行挂载），相关初始化逻辑一定不要放置在 `pageShow` 当中；\r\n* 取消了框架过去提供的基于内部生命周期实现的非标准增强生命周期，如 `beforeCreate/onBeforeCreate` 等，直接将内部生命周期变量导出提供给用户使用，详情查看[这里](https://mpxjs.cn/api/global-api.html#built-in-lifecycle-variable);\r\n* 为了优化 tree shaking，作为框架运行时 `default export` 的 `Mpx` 对象不再挂载 `createComponent/createStore` 等运行时方法，一律通过 `named export` 提供，`Mpx` 对象上仅保留 `set/use` 等全局 API，详情查看[这里](https://mpxjs.cn/api/global-api.html#global-mpx)；\r\n* 使用 I18n 能力时，为了与新版 vue-i18n 保持对齐，`this.$i18n` 对象指向全局作用域，如需创建局部作用域需要使用组合式 API `useI18n` 的方式进行创建。\r\n* `watch` API 不再接受第二个参数为带有 `handler` 属性的对象形式（该参数形式只应存在于 `watch` option 中），第二个参数必须为回调函数，与 [Vue](https://vuejs.org/api/reactivity-core.html#watch) 对齐。\r\n\r\n更详细的迁移指南请点击查看[这里](https://mpxjs.cn/guide/migrate/2.8.html)。\r\n\r\n\r\n## 未来规划\r\n\r\n在完成编译持久化缓存和组合式 API 支持后，我们已经完成了去年规划中最大的两个技术升级，后续我们的技术规划如下：\r\n\r\n* 支持使用 Vite 进行 web 构建\r\n* 完善 Mpx 跨端输出 Hummer 并正式 release\r\n* 优化运行时 render 函数，降低包体积占用\r\n* 内置支持原子类使用\r\n* Mpx-cube-ui 正式开源\r\n\r\n最后，再次感谢所有参与 Mpx 组合式 API 技术建设的同学们，也欢迎社区同学加入 Mpx 项目开源共建。"
    },
    {   "snapshot": "",
        "title": "有哪些适合程序员看的网站？",
        "preview": "程序员网站大汇总，除了技术提升、算法刷题、课程学习、电子书籍的网站，还有兼职副业平台！ 一、技术提升 GitHub 程序员托管代码的平台，很多开发者都会在上面找各种各样的开源项目来学习",
        "author": "飞援",
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/0fb7250be0935d68be63b335f0b6c998~300x300.image",
        "content": "程序员网站大汇总，除了技术提升、算法刷题、课程学习、电子书籍的网站，还有兼职副业平台！\r\n\r\n## 一、技术提升\r\n\r\n### GitHub\r\n\r\n程序员托管代码的平台，很多开发者都会在上面找各种各样的开源项目来学习。阿里、腾讯、字节跳动、美团、Google、Micosoft等国内外大厂都有自己的Github开源库。\r\n\r\n### StackOverflow\r\n\r\n一个强大的IT技术问答网站，用户可以在网站免费提交问题，浏览问题，索引相关内容。\r\n\r\n### GeeksforGeeks\r\n\r\n关于“算法和数据结构”，GeeksforGeeks 有很多很好的文章、解释和代码解决方案。\r\n\r\n### CSDN\r\n\r\n老牌的IT技术交流平台，技术干货很多，但是内容良莠不齐，需要仔细搜寻。\r\n\r\n### 掘金\r\n\r\n技术分享社区，早期以前端技术分享为主，现在覆盖的技术栈较广，网页布局比较清新。\r\n\r\n### 知乎\r\n\r\n知乎上面有很多不错的技术回答，特别是早期有很多技术大佬在上面活跃，在中文社区里面算是质量较高。\r\n\r\n## 二、算法刷题\r\n\r\n### Leetcode\r\n\r\n知名刷题网站，有许多编程面试的题目，可以在线编译运行。通过刷LeetCode可以保持编程状态，同时对于技术面试也有很大帮助。\r\n\r\n### Lintcode\r\n\r\nLintCode 收集了最常见、最高频的编程题目，覆盖领域较多，支持在线编译。\r\n\r\n### TopCoder\r\n\r\nTopCoder 是最早的在线编程竞技平台之一，提供了一系列的算法挑战。他们还会赞助竞赛，如果你写出最好的解决方案，就可以拿到奖励。\r\n\r\n### 牛客网\r\n\r\n在线刷题平台，有很多的企业真题，应届生求职使用的较多。\r\n\r\n## 三、课程学习\r\n\r\n### 哔哩哔哩\r\n\r\n众所周知，“bilibili是一个学习网站”，除了番剧、鬼畜之外，b站同样有非常多的高质量的编程教学视频。\r\n\r\n### Coursera\r\n\r\nCoursera是大型公开在线课程项目，合作院校包括斯坦福大学、密歇根大学、普林斯顿大学、宾夕法尼亚大学等美国名校。你可以在上面学到大量计算机理论和编程知识，部分课程有中文字幕。\r\n\r\n### 慕课网\r\n\r\n国内比较不错的编程教学网站，可以找到比较体系的视频课程，但是要花钱。\r\n\r\n### 中国大学MOOC\r\n\r\n一个综合性的课程平台，拥有包括985高校在内提供的千余门课程。\r\n\r\n### 网易云课堂\r\n\r\n一个综合性的在线学习平台，有一些计算机编程方面的视频教程，同样的，需要花钱。\r\n\r\n## 四、电子书籍\r\n\r\n### 图灵社区\r\n\r\n书籍比较全面的图书社区，电子书的价格是纸质书的一半。\r\n\r\n### 博文视点\r\n\r\n出版了数量众多的计算机类图书，有些书的质量相对较高。\r\n\r\n### 书栈网\r\n\r\n书栈网是一个开源书籍和文档分享站点。\r\n\r\n### IT熊猫\r\n\r\n有数百本热门技术书籍。\r\n\r\n### 极客图书\r\n\r\n可观的技术书籍资源，有些书籍还附带源码。\r\n\r\n## 五、副业兼职\r\n\r\n### 飞援\r\n\r\n程序员远程灵活用工平台，聚集了高质量的兼职和全职自由职业开发者，会对开发者的开发经验有一定要求（会有测评和面试流程），但是结算会比较有保障，平台也会协助跟客户沟通，比较靠谱。"
    },
    {   "snapshot": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c4561eb3be6e4be1915e4256a79d0ee5~tplv-k3u1fbpfcp-watermark.image?",
        "title": "总结：二叉树的属性",
        "preview": "是否对称 给定一个二叉树，检查它是否是镜像对称的。 上图为对称二叉树 上图的二叉树则不是镜像的 思路 判断是否是镜像，需要去判断二叉树的里侧和外侧是否相同。 这就需要去判断根节点下左子树与右子树里侧和",
        "author": "HelloWorld杰少",
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/a2a6fc558f01bff9d77f9039b18debc1~300x300.image",
        "content": "---\r\ntheme: channing-cyan\r\n---\r\n> 持续创作，加速成长！这是我参与「掘金日新计划 · 10 月更文挑战」的第12天，[点击查看活动详情](https://juejin.cn/post/7147654075599978532 \\\"https://juejin.cn/post/7147654075599978532\\\")\r\n\r\n## 是否对称\r\n\r\n给定一个二叉树，检查它是否是镜像对称的。\r\n\r\n![image](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c19d0227f86c4ec0bdb50faa8dd4b33f~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n上图为对称二叉树\r\n\r\n![image](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c875657fbd5c45b69e5a0ec221032225~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n上图的二叉树则不是镜像的\r\n\r\n### 思路\r\n\r\n判断是否是镜像，需要去判断二叉树的里侧和外侧是否相同。\r\n\r\n这就需要去判断根节点下左子树与右子树里侧和外侧是否相等。比较的方法是拿左子树的 “左-右-中” 节点和右子树的“右-左-中”为顺序的节点做比较。\r\n\r\n这题用递归的方式解比较方便，递归的思路如下：\r\n1. 因为要比较俩个子树是否是镜像的，所以递归的参数为俩个，分别是左子树节点和右子树节点\r\n2. 终止条件有三个：\r\n\r\n- 左节点为空，右节点不为空，返回 false，左节点不为空，右节点为空，返回 false；\r\n- 左右节点均不为空，但数值不同，返回 false；\r\n- 如果左右节点均为空，则返回 true；\r\n\r\n3. 如果以上条件均不满足，则再进入递归逻辑\r\n\r\n### 代码实现\r\n\r\n\r\n```\r\npublic boolean isSymmetric1(TreeNode root) {\r\n        return compare(root.left, root.right);\r\n    }\r\n\r\n    private boolean compare(TreeNode left, TreeNode right) {\r\n\r\n        if (left == null && right != null) {\r\n            return false;\r\n        }\r\n        if (left != null && right == null) {\r\n            return false;\r\n        }\r\n\r\n        if (left == null && right == null) {\r\n            return true;\r\n        }\r\n        if (left.val != right.val) {\r\n            return false;\r\n        }\r\n        // 比较外侧\r\n        boolean compareOutside = compare(left.left, right.right);\r\n        // 比较内侧\r\n        boolean compareInside = compare(left.right, right.left);\r\n        return compareOutside && compareInside;\r\n    }\r\n```\r\n\r\n时间复杂度：O(N)，其中 N 是树的节点数。对每个节点访问一次。\r\n\r\n空间复杂度：O(H)，其中 H 是树的高度\r\n\r\n## 二叉树的最大深度\r\n\r\n### 给定一个二叉树，找出其最大深度。\r\n\r\n#### 思路\r\n\r\n二叉树的深度是指根节点到最远叶子节点的最长路径上的节点数。\r\n\r\n我们可以通过递归的方式求解此题：\r\n\r\n1. 递归函数的传入的参数为二叉树的根节点，返回值为二叉树的高度；\r\n2. 递归的终止条件为当节点为空节点时，返回高度为 0；\r\n3. 先求出它左子树的高度，然后再求出它右子树的高度，俩高度的最大值+1为二叉树的最大深度。\r\n\r\n代码如下：\r\n\r\n\r\n```java\r\nclass solution {\r\npublic:\r\n    int getdepth(treenode node) {\r\n        if (node == null) return 0;\r\n        int leftdepth = getdepth(node.left);       // 左\r\n        int rightdepth = getdepth(node.right);     // 右\r\n        int depth = 1 + Math.max(leftdepth, rightdepth); // 中\r\n        return depth;\r\n    }\r\n    int maxdepth(treenode root) {\r\n        return getdepth(root);\r\n    }\r\n};\r\n```\r\n\r\n时间复杂度：O(N)，其中 N 是树的节点数。对每个节点访问一次。\r\n\r\n空间复杂度：O(H)，其中 H 是树的高度\r\n\r\n同理，该方法适用于求 N 叉树的最大深度，代码如下：\r\n\r\n```java\r\n// Definition for a Node.\r\nclass Node {\r\n    public int val;\r\n    public List<Node> children;\r\n\r\n    public Node() {}\r\n\r\n    public Node(int _val) {\r\n        val = _val;\r\n    }\r\n\r\n    public Node(int _val, List<Node> _children) {\r\n        val = _val;\r\n        children = _children;\r\n    }\r\n};\r\n\r\nclass Solution {\r\n  public int maxDepth(Node root) {\r\n    if (root == null) {\r\n      return 0;\r\n    } else if (root.children.isEmpty()) {\r\n      return 1;  \r\n    } else {\r\n      List<Integer> heights = new LinkedList<>();\r\n      // 循环求出每个子树的高度\r\n      for (Node item : root.children) {\r\n        heights.add(maxDepth(item)); \r\n      }\r\n      return Collections.max(heights) + 1;\r\n    }\r\n  }\r\n}\r\n\r\n```\r\n\r\n时间复杂度：O(N)，其中 N 是树的节点数。对每个节点访问一次。\r\n\r\n空间复杂度：O(H)，其中 H 是树的高度\r\n\r\n## 二叉树的最小深度\r\n\r\n说明：最小深度是从根节点到最近叶子节点的最短路径上的节点数量。\r\n\r\n这里有个误区需要解释一下，是从根节点到最近的叶子节点，如果根节点没有左子树或者右子树，很多人就觉得最小深度为 1，这是不对的。是从根节点到最近叶子节点的最短路径上的节点数量才是最小深度。\r\n\r\n可以看出, 求二叉树的最小深度和求二叉树的最大深度的差别主要在于处理左右孩子不为空的逻辑。\r\n\r\n代码如下：\r\n\r\n\r\n```java \r\nclass Solution {\r\n    /**\r\n     * 递归法，相比求MaxDepth要复杂点\r\n     * 因为最小深度是从根节点到最近**叶子节点**的最短路径上的节点数量\r\n     */\r\n    public int minDepth(TreeNode root) {\r\n        if (root == null) {\r\n            return 0;\r\n        }\r\n        int leftDepth = minDepth(root.left);\r\n        int rightDepth = minDepth(root.right);\r\n        if (root.left == null) {\r\n            return rightDepth + 1;\r\n        }\r\n        if (root.right == null) {\r\n            return leftDepth + 1;\r\n        }\r\n        // 左右结点都不为null\r\n        return Math.min(leftDepth, rightDepth) + 1;\r\n    }\r\n}\r\n```\r\n\r\n时间复杂度：O(N)，其中 N 是树的节点数。对每个节点访问一次。\r\n\r\n空间复杂度：O(H)，其中 H 是树的高度。\r\n\r\n\r\n## 求二叉树有多少个节点\r\n\r\n给出一个完全二叉树，求出该树的节点个数。\r\n\r\n此题可用求二叉树的最大深度的方式来求出，代码如下：\r\n\r\n```java\r\nclass solution {\r\npublic:\r\n    int getdepth(treenode node) {\r\n        if (node == null) return 0;\r\n        int leftdepth = getdepth(node.left);       // 左\r\n        int rightdepth = getdepth(node.right);     // 右\r\n        int depth = 1 + leftdepth, rightdepth; // 中\r\n        return depth;\r\n    }\r\n    int maxdepth(treenode root) {\r\n        return getdepth(root);\r\n    }\r\n};\r\n```\r\n\r\n时间复杂度：O(n)，n 为二叉树节点个数\r\n空间复杂度：O(h)，h 为 树的高度\r\n\r\n\r\n## 平衡二叉树\r\n\r\n给定一个二叉树，判断它是否是高度平衡的二叉树。\r\n\r\n本题中，一棵高度平衡二叉树定义为：一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。\r\n\r\n### 思路\r\n\r\n既然是要求比较高度，则我们可以用到后序遍历的方式。\r\n\r\n1. 明确递归函数的参数和返回值，参数为传入的根节点，如果左右子树的返回值 > 1,则我们返回 -1，表示已经不是平衡二叉树了；\r\n2. 递归的终止条件为遇到了空节点，则 return 0, 表示当前节点为 根节点，高度为 0；\r\n3. 单层递归逻辑为，分别求出左右子树的高度，如果差值小于等于 1，则返回当前二叉树的高度，否则返回 -1，表示已经不是二叉树了；\r\n\r\n代码如下：\r\n\r\n```\r\nclass Solution {\r\n   /**\r\n     * 递归法\r\n     */\r\n    public boolean isBalanced(TreeNode root) {\r\n        return getHeight(root) != -1;\r\n    }\r\n\r\n    private int getHeight(TreeNode root) {\r\n        if (root == null) {\r\n            return 0;\r\n        }\r\n        int leftHeight = getHeight(root.left);\r\n        if (leftHeight == -1) {\r\n            return -1;\r\n        }\r\n        int rightHeight = getHeight(root.right);\r\n        if (rightHeight == -1) {\r\n            return -1;\r\n        }\r\n        // 左右子树高度差大于1，return -1表示已经不是平衡树了\r\n        if (Math.abs(leftHeight - rightHeight) > 1) {\r\n            return -1;\r\n        }\r\n        return Math.max(leftHeight, rightHeight) + 1;\r\n    }\r\n}\r\n```\r\n\r\n## 二叉树的所有路劲\r\n\r\n给定一个二叉树，返回所有从根节点到叶子节点的路径。\r\n\r\n### 思路\r\n\r\n根据题意要从根节点到叶子节点的路径，所以需要前序遍历。\r\n\r\n1. 确定递归的参数和返回值，参数为传入的根节点，记录每条路径的节点值数组path，以及路径结果数组res；\r\n2. 当遇到叶子节点的时候终止，并将路径节点值数组里的数值转换成字符串，然后加入到结果数组；\r\n3. 递归的单层逻辑为，因为是前序遍历：中-左-右，所以先处理中间节点，加入到 path 中，然后再递归处理左子树和右子树，并递归完后回溯；\r\n\r\n代码如下：\r\n\r\n```\r\n//解法一\r\nclass Solution {\r\n    /**\r\n     * 递归法\r\n     */\r\n    public List<String> binaryTreePaths(TreeNode root) {\r\n        List<String> res = new ArrayList<>();\r\n        if (root == null) {\r\n            return res;\r\n        }\r\n        List<Integer> paths = new ArrayList<>();\r\n        traversal(root, paths, res);\r\n        return res;\r\n    }\r\n\r\n    private void traversal(TreeNode root, List<Integer> paths, List<String> res) {\r\n        paths.add(root.val);\r\n        // 叶子结点\r\n        if (root.left == null && root.right == null) {\r\n            // 输出\r\n            StringBuilder sb = new StringBuilder();\r\n            for (int i = 0; i < paths.size() - 1; i++) {\r\n                sb.append(paths.get(i)).append(\\\"->\\\");\r\n            }\r\n            sb.append(paths.get(paths.size() - 1));\r\n            res.add(sb.toString());\r\n            return;\r\n        }\r\n        if (root.left != null) {\r\n            traversal(root.left, paths, res);\r\n            paths.remove(paths.size() - 1);// 回溯\r\n        }\r\n        if (root.right != null) {\r\n            traversal(root.right, paths, res);\r\n            paths.remove(paths.size() - 1);// 回溯\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n\r\n## 左叶子之和\r\n\r\n计算给定二叉树的所有左叶子之和。\r\n\r\n### 思路\r\n\r\n首先要判断这棵二叉树有没有左叶子，就必须要通过节点的父节点来判断其左孩子是不是左叶子，判断代码如下：\r\n\r\n```\r\n if (root.left != null && root.left.left == null && root.left.right == null) { // 中\r\n            midValue = root.left.val;\r\n        }\r\n```\r\n\r\n用后序遍历找出所有的左叶子节点数值之和，递归方式如下：\r\n1. 递归函数的传参为根节点，返回值为左叶子节点之和；\r\n2. 递归终止条件为 root == null 返回 0；\r\n3. 单层递归逻辑：当遇到左叶子节点的时候，记录数值，然后通过递归求取左子树左叶子之和，和 右子树左叶子之和，相加便是整个树的左叶子之和；\r\n\r\n代码如下：\r\n\r\n```\r\nclass Solution {\r\n    public int sumOfLeftLeaves(TreeNode root) {\r\n        if (root == null) return 0;\r\n        int leftValue = sumOfLeftLeaves(root.left);    // 左\r\n        int rightValue = sumOfLeftLeaves(root.right);  // 右\r\n                                                       \r\n        int midValue = 0;\r\n        if (root.left != null && root.left.left == null && root.left.right == null) { // 中\r\n            midValue = root.left.val;\r\n        }\r\n        int sum = midValue + leftValue + rightValue;\r\n        return sum;\r\n    }\r\n}\r\n```\r\n\r\n## 左下角的值\r\n\r\n给定一个二叉树，在树的最后一行找到最左边的值。\r\n\r\n### 思路\r\n\r\n本题比较容易下手的解题方式可以用层序遍历的方法，找到最后一行的最左边。\r\n\r\n但是也可以用递归法来实现，首先可以明确深度最大的叶子节点一定是最后一行，那如何找最左边的呢？我们可以使用前序遍历，优先从左边开始搜索。\r\n\r\n1. 明确递归函数的参数和返回值：参数为传入的根节点，以及一个int型变量用来记录最长深度。返回值为 void；\r\n2. 当遇到叶子节点的时候，为终止条件，并开始统计最大深度；\r\n3. 确定单层递归逻辑，当不是叶子节点时，则继续遍历左子树和右子树，并记得要回溯；\r\n\r\n代码如下：\r\n\r\n\r\n```java\r\n// 递归法\r\nclass Solution {\r\n    private int Deep = -1;\r\n    private int value = 0;\r\n    public int findBottomLeftValue(TreeNode root) {\r\n        value = root.val;\r\n        findLeftValue(root,0);\r\n        return value;\r\n    }\r\n\r\n    private void findLeftValue (TreeNode root,int deep) {\r\n        if (root == null) return;\r\n        if (root.left == null && root.right == null) {\r\n            if (deep > Deep) {\r\n                value = root.val;\r\n                Deep = deep;\r\n            }\r\n        }\r\n        if (root.left != null) findLeftValue(root.left,deep + 1);\r\n        if (root.right != null) findLeftValue(root.right,deep + 1);\r\n    }\r\n}\r\n```\r\n\r\n## 路劲总和 1\r\n\r\n给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。\r\n\r\n### 思路\r\n\r\n利用递归来解答此题：\r\n\r\n1. 确定递归函数的传参和返回值：参数为传入的根节点和计数变量，该计数变量每次递归的时候需要减去当前节点的值，最后遇到叶子节点的时候判断该叶子节点的值是否与它一致，如果一致，则表示找到了该路径。返回值为bool类型；\r\n2. 递归函数的终止条件为：当遇到叶子节点的时候，并且计数变量等于叶子节点的值就返回 true;\r\n3. 单层递归逻辑为：遍历左子树和右子树，并回溯\r\n\r\n代码如下：\r\n\r\n```java\r\nclass solution {\r\n   public boolean haspathsum(treenode root, int targetsum) {\r\n        if (root == null) {\r\n            return false;\r\n        }\r\n        targetsum -= root.val;\r\n        // 叶子结点\r\n        if (root.left == null && root.right == null) {\r\n            return targetsum == 0;\r\n        }\r\n        if (root.left != null) {\r\n            boolean left = haspathsum(root.left, targetsum);\r\n            if (left) {// 已经找到\r\n                return true;\r\n            }\r\n        }\r\n        if (root.right != null) {\r\n            boolean right = haspathsum(root.right, targetsum);\r\n            if (right) {// 已经找到\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n}\r\n\r\n// 精简后的代码\r\n\r\nclass solution {\r\n    public boolean haspathsum(treenode root, int targetsum) {\r\n        \r\n        if (root == null) return false; // 为空退出\r\n        \r\n        // 叶子节点判断是否符合\r\n        if (root.left == null && root.right == null) return root.val == targetsum;\r\n\r\n        // 求两侧分支的路径和\r\n        return haspathsum(root.left, targetsum - root.val) || haspathsum(root.right, targetsum - root.val);\r\n    }\r\n}\r\n```\r\n\r\n## 路径总和2\r\n\r\n给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。\r\n\r\n### 思路\r\n\r\n解题思路与上一题相似，只是需要记录路径。\r\n\r\n代码如下：\r\n\r\n```java\r\nclass solution {\r\n    public list<list<integer>> pathsum(treenode root, int targetsum) {\r\n        list<list<integer>> res = new arraylist<>();\r\n        if (root == null) return res; // 非空判断\r\n        \r\n        list<integer> path = new linkedlist<>();\r\n        preorderdfs(root, targetsum, res, path);\r\n        return res;\r\n    }\r\n\r\n    public void preorderdfs(treenode root, int targetsum, list<list<integer>> res, list<integer> path) {\r\n        path.add(root.val);\r\n        // 遇到了叶子节点\r\n        if (root.left == null && root.right == null) {\r\n            // 找到了和为 targetsum 的路径\r\n            if (targetsum - root.val == 0) {\r\n                res.add(new arraylist<>(path));\r\n            }\r\n            return; // 如果和不为 targetsum，返回\r\n        }\r\n\r\n        if (root.left != null) {\r\n            preorderdfs(root.left, targetsum - root.val, res, path);\r\n            path.remove(path.size() - 1); // 回溯\r\n        }\r\n        if (root.right != null) {\r\n            preorderdfs(root.right, targetsum - root.val, res, path);\r\n            path.remove(path.size() - 1); // 回溯\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n**我是杰少，如果您觉的我写的不错，那请给我 **点赞+评论+收藏** 后再走哦！**\r\n\r\n**往期文章：**\r\n\r\n- [使用 Google Breakpad 来助力解决程序崩溃](https://juejin.cn/editor/drafts/7130819289803653128)\r\n- [UE4 多人游戏服务器探索](https://juejin.cn/editor/drafts/7118977305858277412)\r\n- [使用虚幻引擎自动化工具实现自动化部署](https://juejin.cn/editor/drafts/7095681383351681038)\r\n- [如何在 UE4 中制作一扇自动开启的大门](https://juejin.cn/editor/drafts/7083289727268290574)\r\n- [如何在 UE4 中用代码去控制角色移动](https://juejin.cn/editor/drafts/7081045461729017869)\r\n- [如何给 UE4 场景添加游戏角色](https://juejin.cn/editor/drafts/7080302876341305381)\r\n- [UE4：Android 平台开发实践指南](https://juejin.cn/post/7068510988378570783)\r\n- [UE4 开发避坑指南（持续更新）](https://juejin.cn/editor/drafts/7065135005466361887)\r\n- [新年开工啦，放个小烟花庆祝一下](https://juejin.cn/editor/drafts/7062169980636250119)\r\n- [聊聊与苹果审核员的爱恨情仇(下)](https://juejin.cn/post/7051401342547410974)\r\n- [聊聊与苹果审核员的爱恨情仇(上)](https://juejin.cn/post/7046211809170161694)\r\n- [一名普通工具人的 2021 | 2021年终总结](https://juejin.cn/post/7037817537605664781)\r\n- [二叉树刷题总结：二叉搜索树的属性](https://juejin.cn/post/7030031399780352036)\r\n- [二叉树总结：二叉树的属性](https://juejin.cn/post/7027610133165572103)\r\n- [二叉树总结：二叉树的修改与构造](https://juejin.cn/post/7027970630309904421)\r\n- [StoreKit2 有这么香？嗯，我试过了，真香](https://juejin.cn/post/7023974581446639630)\r\n-   [看完这篇文章，再也不怕面试官问我如何构造二叉树啦！](https://juejin.cn/post/7023060069038161934)\r\n-   [那帮做游戏的又想让大家氪金，太坏了！](https://juejin.cn/post/7006540242777800741)\r\n-   [手把手带你撸一个网易云音乐首页 | 适配篇](https://juejin.cn/post/6984062100062601247 \\\"https://juejin.cn/post/6984062100062601247\\\")\r\n-   [手把手带你撸一个网易云音乐首页（三）](https://juejin.cn/post/6981438462318608391 \\\"https://juejin.cn/post/6981438462318608391\\\")\r\n-   [手把手带你撸一个网易云音乐首页（二）](https://juejin.cn/post/6979971385191825445 \\\"https://juejin.cn/post/6979971385191825445\\\")\r\n-   [手把手带你撸一个网易云音乐首页（一）](https://juejin.cn/post/6978374782664310792 \\\"https://juejin.cn/post/6978374782664310792\\\")\r\n-   [代码要写注释吗？写你就输了](https://juejin.cn/post/6965856152315756551 \\\"https://juejin.cn/post/6965856152315756551\\\")\r\n-   [Codable发布这么久我就不学，摸鱼爽歪歪，哎~就是玩儿](https://juejin.cn/post/6960840387216801799 \\\"https://juejin.cn/post/6960840387216801799\\\")\r\n-   [iOS 优雅的处理网络数据，你真的会吗？不如看看这篇](https://juejin.cn/post/6952682593372340237 \\\"https://juejin.cn/post/6952682593372340237\\\")\r\n-   [UICollectionView 自定义布局！看这篇就够了](https://juejin.cn/post/6944994974614323213 \\\"https://juejin.cn/post/6944994974614323213\\\")\r\n\r\n**请你喝杯 ☕️ 点赞 + 关注哦～**\r\n\r\n1.  阅读完记得给我点个赞哦，有👍 有动力\r\n1.  关注公众号--- [HelloWorld杰少](https://link.juejin.cn?target=https%3A%2F%2Fp1-jj.byteimg.com%2Ftos-cn-i-t2oaga2asx%2Fgold-user-assets%2F2020%2F7%2F4%2F17318f81cd4e34e9~tplv-t2oaga2asx-image.image \\\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/4/17318f81cd4e34e9~tplv-t2oaga2asx-image.image\\\")，第一时间推送新姿势\r\n\r\n> 最后，创作不易，如果对大家有所帮助，希望大家点赞支持，有什么问题也可以在评论区里讨论😄～**\r\n"
    },
    {   "snapshot": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/32618ebc15ac44439634301618e2a860~tplv-k3u1fbpfcp-watermark.image?",
        "title": "图片不压缩，前端要背锅 🍳",
        "preview": "身为一个程序员 🧑‍💻 ，不会还有人手动一张张上传图片压缩吧 🌝 ？通过封装好的工具，就能实现自动压缩项目内的图片，彻底释放双手 🤲 ！",
        "author": "JustCarryOn",
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/85b6f586083d78738dd653b7fa01cd31~300x300.image",
        "content": "---\r\ntheme: fancy\r\n---\r\n> 大家好，好久没见，最近有点懒，很久没更新啦。这次要聊的主题是「图片压缩」。在一般页面里面，使用最多的「静态素材」非图片莫属了，这次轮到对它动手 👊 ！\r\n\r\n## 背景\r\n\r\n🎨(美术): 这是这次需求的切图 📁 ，你看看有没问题？ \r\n\r\n🧑‍💻(前端): 好的。\r\n\r\n页面上线 ...\r\n\r\n🧑‍💼(产品): 这图片怎么半天加载不出来 💢 ？\r\n\r\n🧑‍💻(前端): 我看看 🤔 (卑微)。\r\n\r\n... 📁(size: 15MB)\r\n\r\n🧑‍💻(前端): 😅。\r\n\r\n很多时候，我们从 `PS` 、`蓝湖`或`摹客`等工具导出来的图片，或者是美术直接给到切图，都是未经过压缩的，体积都比较大。这里，就有了可优化的空间。\r\n\r\n## TinyPng\r\n\r\n> `TinyPNG`使用智能的「有损压缩技术」来减少`WEBP`、`JPEG`和`PNG`文件的文件大小。通过选择性地减少图像中的「颜色数量」，使用更少的字节来存储数据。这种效果几乎是看不见的，但在文件大小上有非常大的差别。\r\n\r\n使用过[TinyPng](https://tinypng.com/)的都知道，它的压缩效果非常好，体积大幅度降低且显示效果几乎没有区别( 👀 看不出区别）。因此，选择其作为压缩工具，是一个不错的选择。\r\n\r\n`TinyPng`提供两种压缩方法：\r\n1. 通过在官网上进行手动压缩；\r\n2. 通过官方提供的`tinify`进行压缩；\r\n\r\n身为一个程序员 🧑‍💻 ，是不能接受手动一张张上传压缩这种方法的。因此，选择第二种方法，通过封装一个工具，对项目内的图片自动压缩，彻底释放双手 🤲 。\r\n\r\n## 工具类型\r\n\r\n第一步，思考这个工具的「目的」是什么？没错，「压缩图片」。\r\n\r\n第二步，思考在哪个「环节」进行压缩？没错，「发布前」。\r\n\r\n这样看来，开发一个`webpack plugin`是一个不错选择，在打包「生产环境」代码的时候，启用该`plugin`对图片进行处理，完美 🥳 ！\r\n\r\n但是，这样会面临两个问题 🤔 ：\r\n1. 页面迭代，新增了几张图片，重新打包上线时，会导致旧图片被多次压缩；\r\n2. 无法选择哪些图片要被压缩，哪些图片不被压缩；\r\n\r\n虽然可以通过「配置」的方式解决上述问题，但每次打包都要特殊配置，略显麻烦，这样看来`plugin`好像不是最好的选择。\r\n\r\n以上两个问题，使用「命令行工具」就能完美解决。在打包「生产环境」代码之前，执行「压缩命令」，通过命令行交互，选择需要压缩的图片。\r\n\r\n## 效果演示\r\n\r\n话不多说，先上才艺 💃 ！\r\n\r\n1. 安装\r\n\r\n```\r\n$ npm i yx-tiny -D\r\n```\r\n\r\n2. 使用\r\n\r\n```\r\n$ npx tiny \r\n```\r\n\r\n3. 根据命令行提示输入\r\n\r\n![10月10日.2022-10-10 5_57_17 PM.gif](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/edc39ef452134045a9cb68242705b415~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n流程：输入「文件夹名称-`tinyImg`」，接着工具会找到当前项目下所有的`tinyImg`，接着选择一或多个`tinyImg`，紧接着，工具会找出`tinyImg`下所有的`png`、`jpe?g`和`svga`，最后选择压缩模式「全量」或「自定义」，选择需要压缩的图片。\r\n\r\n从最后的输出结果可以看到，压缩前的资源体积为`2.64MB`，压缩后体积为`1.02MB`，足足压缩了`1.62MB` 👍 ！\r\n\r\n## 实现思路\r\n\r\n总体分为五个过程：\r\n1. 查找：找出所有的图片资源；\r\n2. 分配：均分任务到每个进程；\r\n3. 上传：把原图上传到`TinyPng`；\r\n4. 下载：从`TinyPng`中下载压缩好的图片；\r\n5. 写入：用下载的图片覆盖本地图片；\r\n\r\n项目地址：[yx-tiny](https://github.com/yxichan/lerna-npm/tree/master/packages/tiny)\r\n\r\n### 查找\r\n\r\n找出所有的图片资源。\r\n> packages/tiny/src/index.ts\r\n```ts\r\n/**\r\n * 递归找出所有图片\r\n * @param { string } path\r\n * @returns { Array<imageType> }\r\n */\r\ninterface IdeepFindImg {\r\n  (path: string): Array<imageType>\r\n}\r\nlet deepFindImg: IdeepFindImg\r\ndeepFindImg = (path: string) => {\r\n  // 读取文件夹的内容\r\n  const content = fs.readdirSync(path)\r\n  // 用于保存发现的图片\r\n  let images: Array<imageType> = []\r\n  // 遍历该文件夹内容\r\n  content.forEach(folder => {\r\n    const filePath = resolve(path, folder)\r\n    // 获取当前内容的语法信息\r\n    const info = fs.statSync(filePath)\r\n    // 当前内容为“文件夹”\r\n    if (info.isDirectory()) {\r\n      // 对该文件夹进行递归操作\r\n      images = [...images, ...deepFindImg(filePath)]\r\n    } else {\r\n      const fileNameReg = /\\\\.(jpe?g|png|svga)$/\r\n      const shouldFormat = fileNameReg.test(filePath)\r\n      // 判断当前内容的路径是否包含图片格式\r\n      if (shouldFormat) {\r\n        // 读取图片内容保存到images\r\n        const imgData = fs.readFileSync(filePath)\r\n        images.push({\r\n          path: filePath,\r\n          file: imgData\r\n        })\r\n      }\r\n    }\r\n  })\r\n  return images\r\n}\r\n```\r\n通过命令行交互后，拿到目标文件夹的路径`path`，然后获取该`path`下的所有内容，接着遍历所有内容。首先判断该内容的文件信息：若为“文件夹”，则把该文件夹路径作为`path`，递归调用`deepFindImg`；若不为“文件夹”，判断该内容为图片，则读取图片数据，`push`到`images`中。最后，返回所有找到的图片。\r\n\r\n### 分配\r\n\r\n均分任务到每个进程。\r\n\r\n> packages/tiny/src/index.ts\r\n```ts\r\n// ...\r\ncluster.setupPrimary({\r\n    exec: resolve(__dirname, 'features/process.js')\r\n})\r\n\r\n// 若资源数小于则创建一个进程，否则创建多个进程\r\nconst works: Array<{\r\n    work: Worker;\r\n    tasks: Array<imageType>\r\n}> =[]\r\nif (list.length <= cpuNums) {\r\n    works.push({\r\n        work: cluster.fork(),\r\n        tasks: list\r\n    })\r\n} else {\r\n    for (let i = 0; i < cpuNums; ++i) {\r\n        const work = cluster.fork()\r\n        works.push({\r\n            work,\r\n            tasks: []\r\n        })\r\n    }\r\n}\r\n\r\n// 平均分配任务\r\nlet workNum = 0 \r\nlist.forEach(task = >{\r\n    if (works.length === 1) {\r\n        return\r\n    } else if (workNum >= works.length) {\r\n        works[0].tasks.push(task)\r\n        workNum = 1\r\n    } else {\r\n        works[workNum].tasks.push(task)\r\n        workNum += 1\r\n    }\r\n})\r\n\r\n// 用于记录进程完成数\r\nlet pageNum = works.length\r\n\r\n// 初始化进度条\r\n// ...\r\n\r\nworks.forEach(({\r\n    work,\r\n    tasks\r\n}) = >{\r\n    // 发送任务到每个进程\r\n    work.send(tasks)\r\n    // 接收任务完成\r\n    work.on('message', (details: Idetail[]) = >{\r\n        // 更新进度条\r\n        // ...\r\n        pageNum--\r\n        // 所有任务执行完毕\r\n        if (pageNum === 0) {\r\n            // 关闭进程\r\n            cluster.disconnect()\r\n        }\r\n    })\r\n})\r\n```\r\n\r\n使用`cluster`，根据「cpu核心数」创建等量的进程，`works`用于保存已创建的进程，`list`中保存的是要处理的压缩任务，通过遍历`list`，把任务依次分给每一个进程。接着遍历`works`，通过`send`方法发送进程任务。通过监听`message`事件，利用`pageNum`记录进程任务的完成情况，当所有进程任务执行完毕后，则关闭进程。\r\n\r\n### 上传\r\n\r\n官方提供的`tinify`工具有「500张/月」的限额，超过限额后，需要付费。\r\n\r\n![截屏2022-10-10 下午6.33.48.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/82e9baf8650c4f0eb47f68b08f913eaa~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n由于家境贫寒，且出于学习的目的，就没有使用`tinify`，而是通过构造随机`IP`来直接请求「压缩接口」来达到「破解限额」的目的。大家在真正使用的时候，还是要使用`tinyfy`来压缩，不要做这种投机取巧的事。\r\n\r\n好了，回到正文。\r\n\r\n把原图上传到`TinyPng`。\r\n\r\n> packages/tiny/src/features/index.ts\r\n```ts\r\n/**\r\n * 上传函数\r\n * @param { Buffer } file 文件buffer数据\r\n * @returns { Promise<DataUploadType> }\r\n */\r\ninterface Iupload {\r\n  (file: Buffer): Promise<DataUploadType>\r\n}\r\nexport let upload: Iupload\r\nupload = (file: Buffer) => {\r\n  // 生成随机请求头\r\n  const header = randomHeader()\r\n  return new Promise((resolve, reject) => {\r\n    const req = Https.request(header, res => {\r\n      res.on('data', data => {\r\n        try {\r\n          const resp = JSON.parse(data.toString()) as DataUploadType\r\n          if (resp.error) {\r\n            reject(resp)\r\n          } else {\r\n            resolve(resp)\r\n          }\r\n        } catch (err) {\r\n          reject(err)\r\n        }\r\n      })\r\n    })\r\n    // 上传图片buffer\r\n    req.write(file)\r\n    req.on('error', err => reject(err))\r\n    req.end()\r\n  })\r\n}\r\n```\r\n使用`node`自带的`Https`模块，构造请求头，把`deepFindImg`中返回的图片进行上传。上传成功后，会返回已经压缩好的图片的`url`链接。\r\n\r\n\r\n### 下载\r\n\r\n从`TinyPng`中下载压缩好的图片。\r\n\r\n> packages/tiny/src/features/index.ts\r\n```ts\r\n/**\r\n * 下载函数\r\n * @param { string } path\r\n * @returns { Promise<string> }\r\n */\r\ninterface Idownload {\r\n  (path: string): Promise<string>\r\n}\r\nexport let download: Idownload\r\ndownload = (path: string) => {\r\n  const header = new Url.URL(path)\r\n  return new Promise((resolve, reject) => {\r\n    const req = Https.request(header, res => {\r\n      let content = ''\r\n      res.setEncoding('binary')\r\n      res.on('data', data => (content += data))\r\n      res.on('end', () => resolve(content))\r\n    })\r\n    req.on('error', err => reject(err))\r\n    req.end()\r\n  })\r\n}\r\n```\r\n使用`node`自带的`Https`模块把`upload`中返回的图片链接进行下载。下载成功后，返回图片的`buffer`数据。\r\n\r\n### 写入\r\n\r\n把下载好的图片覆盖本地图片。\r\n\r\n> packages/tiny/src/features/process.ts\r\n```ts\r\n/**\r\n * 接收进程任务\r\n */\r\nprocess.on('message', (tasks: imageType[]) => {\r\n  ;(async () => {\r\n    // 优化 png/jpg\r\n    const data = tasks\r\n      .filter(({ path }: { path: string }) => /\\\\.(jpe?g|png)$/.test(path))\r\n      .map(ele => {\r\n        return compressImg({ ...ele, file: Buffer.from(ele.file) })\r\n      })\r\n\r\n    // 优化 svga\r\n    const svgaData = tasks\r\n      .filter(({ path }: { path: string }) => /\\\\.(svga)$/.test(path))\r\n      .map(ele => {\r\n        return compressSvga(ele.path, Buffer.from(ele.file))\r\n      })\r\n\r\n    const details = await Promise.all([\r\n      ...data.map(fn => fn()),\r\n      ...svgaData.map(fn => fn())\r\n    ])\r\n\r\n    // 写入\r\n    await Promise.all(\r\n      details.map(\r\n        ({ path, file }) =>\r\n          new Promise((resolve, reject) => {\r\n            fs.writeFile(path, file, err => {\r\n              if (err) reject(err)\r\n              resolve(true)\r\n            })\r\n          })\r\n      )\r\n    )\r\n\r\n    // 发送结果\r\n    if (process.send) {\r\n      process.send(details)\r\n    }\r\n  })()\r\n})\r\n```\r\n`process.on`监听每个进程发送的任务，当接收到任务类型为「图片」，使用`compressImg`方法来处理图片。当任务类型为「svga」，使用`compressSvga`方法来处理`svga`。最后把处理好的资源写入到本地覆盖旧资源。\r\n\r\n#### compressImg\r\n\r\n> packages/tiny/src/features/process.ts\r\n```ts\r\n/**\r\n * 压缩图片\r\n * @param { imageType } 图片资源\r\n * @returns { promise<Idetail> }\r\n */\r\ninterface IcompressImg {\r\n  (payload: imageType): () => Promise<Idetail>\r\n}\r\nlet compressImg: IcompressImg\r\ncompressImg = ({ path, file }: imageType) => {\r\n  return async () => {\r\n    const result = {\r\n      input: 0,\r\n      output: 0,\r\n      ratio: 0,\r\n      path,\r\n      file,\r\n      msg: ''\r\n    }\r\n    try {\r\n      // 上传\r\n      const dataUpload = await upload(file)\r\n\r\n      // 下载\r\n      const dataDownload = await download(dataUpload.output.url)\r\n\r\n      result.input = dataUpload.input.size\r\n      result.output = dataUpload.output.size\r\n      result.ratio = 1 - dataUpload.output.ratio\r\n      result.file = Buffer.alloc(dataDownload.length, dataDownload, 'binary')\r\n    } catch (err) {\r\n      result.msg = `[${chalk.blue(path)}] ${chalk.red(JSON.stringify(err))}`\r\n    }\r\n    return result\r\n  }\r\n}\r\n```\r\n\r\n`compressImg`返回一个`async`函数，该函数先调用`upload`进行图片上传，接着调用`download`进行下载，最终返回该图片的`buffer`数据。\r\n\r\n#### compressSvga\r\n> packages/tiny/src/features/process.ts\r\n```ts\r\n/**\r\n * 压缩svga\r\n * @param { string } path 路径\r\n * @param { buffer } source svga buffer\r\n * @returns { promise<Idetail> }\r\n */\r\ninterface IcompressSvga {\r\n  (path: string, source: Buffer): () => Promise<Idetail>\r\n}\r\nlet compressSvga: IcompressSvga\r\ncompressSvga = (path, source) => {\r\n  return async () => {\r\n    const result = {\r\n      input: 0,\r\n      output: 0,\r\n      ratio: 0,\r\n      path,\r\n      file: source,\r\n      msg: ''\r\n    }\r\n    try {\r\n      // 解析svga\r\n      const data = ProtoMovieEntity.decode(\r\n        pako.inflate(toArrayBuffer(source))\r\n      ) as unknown as IsvgaData\r\n      const { images } = data\r\n      const list = Object.keys(images).map(path => {\r\n        return compressImg({ path, file: toBuffer(images[path]) })\r\n      })\r\n\r\n      // 对svga图片进行压缩\r\n      const detail = await Promise.all(list.map(fn => fn()))\r\n      detail.forEach(({ path, file }) => {\r\n        data.images[path] = file\r\n      })\r\n\r\n      // 压缩buffer\r\n      const file = pako.deflate(\r\n        toArrayBuffer(ProtoMovieEntity.encode(data).finish() as Buffer)\r\n      )\r\n      result.input = source.length\r\n      result.output = file.length\r\n      result.ratio = 1 - file.length / source.length\r\n      result.file = file\r\n    } catch (err) {\r\n      result.msg = `[${chalk.blue(path)}] ${chalk.red(JSON.stringify(err))}`\r\n    }\r\n    return result\r\n  }\r\n}\r\n```\r\n\r\n`compressSvga`的「输入」、「输出」和`compressImg`保持一致，目的是为了可以使用`promise.all`同时调用。在`compressSvga`内部，对`svga`进行解析成`data`，获取到`svga`的图片列表`images`，接着调用`compressImg`对`images`进行压缩，使用压缩后的图片覆盖`data.images`，最后再把`data`编码后，写入到本地覆盖原本的`svga`。\r\n\r\n## 最后\r\n\r\n再说一遍，大家真正使用的时候，要使用官方的`tinify`进行压缩。\r\n\r\n参考文章：\r\n\r\n-   [protobuf.js](https://github.com/protobufjs/protobuf.js)\r\n-   [SVGAPlayer-Web-Lite](https://github.com/svga/SVGAPlayer-Web-Lite)\r\n-   [tinify](https://tinypng.com/developers/reference/nodejs)\r\n\r\n祝大家生活愉快，工作顺利！\r\n\r\n「 --- The end --- 」"
    },
    {   "snapshot": "https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d269a4937bf34f32a5bc56d8b01562cd~tplv-k3u1fbpfcp-watermark.image?",
        "title": "2023 届秋招回顾，寒气逼人。。。",
        "preview": "最近几天朋友圈被一篇文章刷屏了，是一位参与了 2023 届秋招的同学分享的秋招回顾总结。 都说今年的秋招难，寒气弥漫，那我们一起来看看这位同学是如何准备秋招、如何应对焦虑，最终拿到 offer 的吧！",
        "author": "程序员追风",
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/ba74cb9d376f8f84e5cf942c321d9b86~300x300.image",
        "content": "最近几天朋友圈被一篇文章刷屏了，是一位参与了 2023 届秋招的同学分享的秋招回顾总结。\r\n\r\n都说今年的秋招难，寒气弥漫，那我们一起来看看这位同学是如何准备秋招、如何应对焦虑，最终拿到 offer 的吧！\r\n\r\n以下是他的分享：\r\n\r\n> 原文链接：https://www.cnblogs.com/yuanchuziwen/p/16770895.html\r\n> \r\n> 作者：OliQ\r\n\r\n# 自我介绍\r\n\r\n我来自杭州的一所双非一本学校，是一名普通的本科生，专业【软件工程】。\r\n\r\n## 初学编程\r\n\r\n事实上，我从高中毕业起就开始思考未来的工作了，一开始网上都是 Python 相关的新闻，因此从高中毕业的暑假就开始学 Python，当时在新华书店，捧着一本入门书天天看；\r\n\r\n但是看了并没有什么用，除了大一的时候吹牛皮，啥都没学到。\r\n\r\n然后自 2020 年初(大一寒假) 疫情爆发，学校线上授课；课程中有【面向对象语言】的学习，自此开始正式的跟着视频学习 Java 了。\r\n\r\n## 第一次实习\r\n\r\n2021年暑假(大二暑假)，我的绩点排名在学校保研线边缘徘徊，但又不愿去刷那些水课的绩点，因此决定考研或者工作，期间比较迷茫。\r\n\r\n当时在网上得到一位大数据方向前辈的指点，他说了一句话：“早，就是优势。”\r\n\r\n因此，我决定先去实习，当时在杭州人工智能小镇找了家公司实习。\r\n\r\n虽说是实习，但其实基本每天上班啥也不干，主管也没分配任务，就是一直在看书，期间看完了周志明老师的 JVM，以及几本讲并发编程的书。\r\n\r\n## 第二次实习\r\n\r\n大三上时，眼看着 Java 越来越卷，自己开始学习了大数据相关的组件，像 Hadoop、HBase、Flume 等等组件，一直学到了实时计算之前。\r\n\r\n大三下时，我明白自己是一个心态非常不稳定的人，考研对我来说，最后几个月会非常的难熬，并且考研失败的风险也让我望而却步，因此下定决心本科就业！\r\n\r\n寒假的时候跟着视频完成了【谷粒商城】那个项目，之后立刻着手准备找实习。\r\n\r\n也就是在这第二段实习过程中(2022上半年)，我真正的学到了一些实际的开发技巧。\r\n\r\n实习期间，看完了几本深入讲中间件 ZK、Redis、Spring源码 和 代码重构的书。\r\n\r\n本次实习，让我受益良多，由衷感谢我的 mentor（导师）和主管！\r\n\r\n# 秋招情况\r\n\r\n我从 6 月底开始复习准备，因为准备得比较晚，所以基本没参加提前批。\r\n\r\n正式批总共投递了近 150 家公司，笔试了 30 家，面试了 15 个公司，除了海康威视，其他基本都意向或排序了。\r\n\r\n大致情况如下：\r\n\r\n-   offer：兴业数金\r\n-   意向：猿辅导，Aloudata\r\n-   排序 / 审批：华为，网易雷火，荣耀，招银网络，古茗奶茶，CVTE，以及一众独角兽公司\r\n-   面试挂：海康威视\r\n\r\n## CVTE 提前批面试（已拒）\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a854792cb6334e9388f4ea7e05520a46~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n## 大应科技（OC）\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bdb1a384652c48e3a69aac60ef7e1284~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n\r\n## e签宝 提前批（已拒）\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/072ce7fc5249461b9b9490481fd79cd6~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n\r\n## 荣耀 Honor（录用决策中）\r\n\r\n![图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/74b4e84f242d491ba69acdff1f112b76~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n## 猿辅导（OC）\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c48c60fe3bf5481cb306b2802087ac1d~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n## 趣链科技（流程中）\r\n\r\n![图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6d760694d8294b3e95d9dfefb94c6a6f~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n## 海康威视（已挂）\r\n\r\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d3c4f95b5bc40c18bb1c43bc412404f~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n## SMART（已拒）\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7c99b296eba544729fdb130c330cbc9a~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n## 寒王厂（泡池子）\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3eaf6481144648e49ca79ff6e4be5562~tplv-k3u1fbpfcp-zoom-1.image)  \r\n\r\n## 网易雷火（排序中）\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cddc3b08edad48b8b6650037b1732c92~tplv-k3u1fbpfcp-zoom-1.image)  \r\n\r\n## 招银网络（流程中）\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f05f676cd1434d5bbc3949c0826c3889~tplv-k3u1fbpfcp-zoom-1.image)\r\n  \r\n## 古茗奶茶（流程中）\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1872c11bc381495d82b8dfdd4d155510~tplv-k3u1fbpfcp-zoom-1.image) \r\n\r\n# 复习方式\r\n\r\n## 关于焦虑\r\n\r\n我们先要肯定一点，在复习的时候，【焦虑】是一件必然的事情，我们要正视焦虑。\r\n\r\n就拿我自己举例子吧，【双非本科】的学历会把我放到一个最最糟糕的位置。\r\n\r\n自开始复习时，我内心就非常非常的焦虑，胸膛经常会像要爆炸一样的沉闷(真的)...\r\n\r\n而我的缓解方式主要分为两种吧：\r\n\r\n-   运动  \r\n\r\n-   -   背一会八股或者刷一会题之后就去走走\r\n    -   每天晚上去操场跑步\r\n\r\n-   心理慰藉    \r\n-   -   面试前，我会像《三傻大闹宝莱坞》里的阿米尔汗一样，拍着自己的胸口对自己说 “Aal izz well”\r\n    -   给自己想好一个下下策，如果秋招真的找不到工作该怎么办？那至少还有春招，对比明年考研失利的同学，我至少积累了经验！\r\n\r\n## 复习流程\r\n\r\n我的整体复习流程分为三步：\r\n\r\n-   处理基础知识\r\n-   看八股\r\n-   查漏补缺\r\n\r\n### 阶段一：处理基础知识\r\n\r\n对于基础知识部分，我自知《计网》和《操作系统》这两门课学的很差，所以一开始就复习这部分知识。\r\n\r\n当时先把两门课的教材翻了一遍，然后做了一些摘抄，但说实话基本没用。\r\n\r\n这部分知识，我在面试过程中，大概有 50% 的几率会被问到操作系统，但从来没被问到过计网(幸运)。\r\n\r\n之后复习《设计模式》，先跟着一个 csdn 上的博客边看别写，之后找了一个很老的(2003年)博客总结，反复背诵，基本能手写大部分的模式实现了。\r\n\r\n这部分知识，我在面试过程中，要求写过 单例 、三大工厂 和 发布订阅 的实现，问过项目中和 Spring 以及其它中间件中用到的设计模式。\r\n\r\n### 阶段二：看八股\r\n\r\n全面进军 Java 八股文。\r\n\r\n我先看了自己在实习前准备的那些文档，之后网上找了 JavaGuide、JavaKeeper 这两份文档作为补充。\r\n\r\n因为自己之前有过两段的实习经验，因此背过很多次八股。\r\n\r\n但考虑到本次秋招可能会把战线拉得比较长，因此就自己总结了一份脑图。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9a235705365f427790a4c8b7c7aa505a~tplv-k3u1fbpfcp-zoom-1.image)  \r\n\r\n### 阶段三：查漏补缺\r\n\r\n经过几轮面试，逐渐察觉到了自己的一些不足，之后针对性的去完善了一下。\r\n\r\n这里随便列举几个点，供其它同学参考：\r\n\r\n-   为什么说进程切换开销比线程大？\r\n-   NIO到底有没有阻塞，NIO到底能不能提高 IO 效率？\r\n-   Redis分布式锁的限制，RedLock的实现？\r\n-   ZK 明明有了有序的指令队列，为什么还要用 zxid来辅助排序？\r\n-   basic paxos 和 multi paxos 的使用？\r\n-   为什么拜占庭将军无解？\r\n-   还有一些业务场景的选择问题。。。\r\n\r\n# 总结\r\n\r\n我一直提醒自己：你是一个双非本科生，这个秋招你如果再不拼命，你就要完蛋了。\r\n\r\n我想，我是幸运的：\r\n\r\n-   我很幸运 在实习的时候，有一个好的 mentor，带我开发了字节码相关的组件，让我的简历不容易挂；\r\n-   我很幸运 在复习的时候，有几位好的朋友，分享经验，加油鼓励，让我没有被焦虑击倒；\r\n-   我很幸运 在面试的时候，有无私的舍友们，能在我需要笔试面试时，把宿舍让给我，让我没有后顾之忧；\r\n\r\n当然，也会有遗憾。每个人心中都有着大厂梦，而今年进大厂确实很难：\r\n\r\n-   我从大一开始就非常渴望进入阿里巴巴，实习的时候五面阿里不得，秋招全部简历挂；\r\n-   百度+度小满，投了 4 个岗位，全部简历挂；\r\n-   字节，一开始担心算法没敢投，之后担心基础知识也没敢投，也很遗憾了；\r\n\r\n人生，有所得就有所失，有所失就有所得。\r\n\r\n最后，想给其他明后年参加秋招的同学一些提醒：\r\n\r\n-   一定要早做准备，早点实习，早点刷算法题，早就是优势；\r\n-   人生无常，意外太多，绝对不要 all in 一家公司；\r\n-   鞋合不合适只有脚知道，自己总结的八股会更适合自己；\r\n-   多刷 力扣 Hot 100，或者 Codetop 热门题，反复刷；\r\n-   选择大于努力；\r\n\r\n在寒气逼人的 2022，我们需要抱团取暖...\r\n\r\n推荐： [2022年Java面试题目收集整理归纳（持续更新）](<https://juejin.cn/post/7135332975440789518>)\r\n"
    },
    {   "snapshot": "https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a0f037462f754fbdb8b0a11e6c4a8e8d~tplv-k3u1fbpfcp-watermark.image?",
        "title": "为什么有公司规定所有接口都用Post？",
        "preview": "看到这个标题，你肯定觉得离谱。怎么会有公司规定所有接口都用Post，是架构菜还是开发菜。这可不是夸大其词，这样的公司不少。在特定的情况下，规定使用Post可以减少不少的麻烦，一起看看。",
        "author": "正经程序员",
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/5c4578847d69f49fdbdc232ec9c53549~300x300.image",
        "content": "---\r\ntheme: condensed-night-purple\r\n---\r\n携手创作，共同成长！这是我参与「掘金日新计划 · 8 月更文挑战」的第8天，[点击查看活动详情](https://juejin.cn/post/7123120819437322247)\r\n\r\n看到这个标题，你肯定觉得离谱。怎么会有公司规定所有接口都用Post，是架构菜还是开发菜。这可不是夸大其词，这样的公司不少。\r\n\r\n在特定的情况下，规定使用Post可以减少不少的麻烦，一起看看。\r\n\r\n# Answer the question\r\n\r\n我们都知道，get请求一半用来获取服务器信息，post一般用来更新信息。get请求能做的，post都能做，get请求不能做的，post也都能做。\r\n\r\n如果你的团队都是大佬，或者有着良好的团队规范，所有人都在平均水平线之上，并且有良好的纠错机制，那基本不会制定这样的规则。\r\n\r\n但如果团队成员水平参差不齐，尤其是小团队，创业团队，常常上来就开干，没什么规范，纯靠开发者个人素质决定代码质量，这样的团队就不得不制定这样的规范。\r\n\r\n毕竟可以减少非常多的问题，Post不用担心URL长度限制，也不会误用缓存。通过一个规则减少了出错的可能，这个决策性价比极高。\r\n\r\n造成的结果：公司有新人进来，什么lj公司，还有这种要求，回去就在群里讲段子。\r\n\r\n实际上都是有原因的。\r\n\r\n有些外包公司或者提供第三方接口的公司也会选择只用Post，就是图个方便。\r\n\r\n# 最佳实践\r\n\r\n可能各位大佬都懂了哈，我还是给大家科普下，GET、POST、PUT、DELETE，他们的区别和用法。\r\n\r\n## GET\r\n\r\nGET 方法用于从服务器检索数据。这是一种只读方法，因此它没有改变或损坏数据的风险，使用 GET 的请求应该只被用于获取数据。\r\n\r\nGET API 是幂等的。 每次发出多个相同的请求都必须产生相同的结果，直到另一个 API（POST 或 PUT）更改了服务器上资源的状态。\r\n\r\n## POST\r\n\r\nPOST 方法用于将实体提交到指定的资源，通常导致在服务器上的状态变化或创建新资源。POST既不安全也不幂等，调用两个相同的 POST 请求将导致两个不同的资源包含相同的信息（资源 ID 除外）。\r\n\r\n\r\n## PUT\r\n主要使用 PUT API更新现有资源（如果资源不存在，则 API 可能决定是否创建新资源）。\r\n\r\n## DELETE\r\n\r\nDELETE 方法删除指定的资源。DELETE 操作是幂等的。如果您删除一个资源，它会从资源集合中删除。\r\n\r\n\r\n|  | GET |POST|PUT|DELETE|\r\n| --- | --- |--- |--- |--- |\r\n| 请求是否有主体 | 否 |是 |是  |可以有|\r\n|成功的响应是否有主体|是|是| 否 |可以有|\r\n|安全|是|否| 否 |否|\r\n|幂等|是|否| 是 |是|\r\n|可缓存|是|否| 否 |否|\r\n|HTML表单是否支持|是|是| 否 |否|\r\n\r\n**你们公司有啥奇葩规定吗？咱们评论区见，我是正经程序员，欢迎点赞收藏关注，感谢！**\r\n\r\n"
    },
    {   "snapshot": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/41016b4e05a042fca2cf0b021d032502~tplv-k3u1fbpfcp-watermark.image?",
        "title": "😈当一个摆子前端太闲的时候会做什么",
        "preview": "今日周二，在下与诸位同道中人一起来讨论一个话题：当一个前端空闲的时候会做些什么。 🤯是独自深耕论坛，钻研学术？ 👯还是三两闲聊打趣，坐而论道？ 💆‍♂️亦或是闭目养神，神游天地？",
        "author": "Urias",
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/ea29f8dff26262b09b39686e5578462f~300x300.image",
        "content": "---\r\ntheme: channing-cyan\r\nhighlight: an-old-hope\r\n---\r\n\r\n> 国破山河在，城春草木深。 ——杜甫·春望\r\n\r\n今日周一，在下与诸位同道中人一起来讨论一个话题：**当一个前端空闲的时候会做些什么**。\r\n\r\n🤯是独自深耕论坛，钻研学术？\r\n\r\n👯还是三两闲聊打趣，坐而论道？\r\n\r\n💆‍♂️亦或是闭目养神，神游天地？\r\n\r\n---\r\n\r\n作为一名优秀的（摆子、摸鱼、切图...）前端开发者，在下在空闲时间最喜欢做的还是钻研（混）前端技术（工作量）。\r\n\r\n新的一周，新的开始，上篇文章中有同学批评在下说不够“玩”，那么**这周**就“简单”画一个鼠标精灵再交予各位“玩一玩”吧。\r\n\r\n> 说明一下：在下说的玩，是写一遍嗷\r\n>\r\n> `温馨提示`：文章较长，图片较多，不耐看的同学可以先去文末玩一玩在下的“大眼”，不满足了再去创造属于各位自己的鼠标精灵\r\n\r\n以下是这周“玩具”的简单介绍：\r\n\r\n- 名称：大眼\r\n- 生辰：发文时间的昨天(2022-08-15)\r\n- 性别：随意\r\n- 情绪：发怒/常态\r\n- 状态：休眠/工作中\r\n- 简介：没啥特别的，大眼就干一件事，就是盯着你的鼠标，以防你找不到鼠标了。不过大眼有起床气，而且非常懒散，容易犯困。\r\n\r\n大眼生活照： \r\n\r\n<p align=center><img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fd075386cda0486aa7b47d39562b5a40~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"image.png\\\"  width=\\\"70%\\\"/></p>\r\n\r\n接下来请各位跟随在下的节奏，一步一步把自己的“大眼”创造出来。\r\n\r\n### 👀 画“大眼”先画圆\r\n\r\n老话说“画人先画骨”，同样画大眼也得先画它的骨，嗯......也就是个圆，没错，就是个普通的圆\r\n\r\n在下的笔法还是老套路，先给他一个容器。\r\n\r\n```html\r\n<div class=\\\"eyeSocket\\\"></div>\r\n```\r\n\r\n给大眼容器添加一些必要的样式\r\n\r\n```css\r\nbody {\r\n    width: 100vw;\r\n    height: 100vh;\r\n    overflow: hidden;\r\n    background-color: #111;\r\n}\r\n.eyeSocket {\r\n    position: absolute; // 浮动居中\r\n    left: calc(50% - 75px);\r\n    top: calc(50% - 75px);\r\n    width: 150px; // 固定宽度\r\n    aspect-ratio: 1; // 长宽比 1:1 如果浏览器不支持该属性，换成 height: 150px 也一样\r\n    border-radius: 50%;\r\n    border: 4px solid rgb(41, 104, 217);\r\n    z-index: 1;\r\n}\r\n```\r\n\r\n效果：\r\n\r\n<p align=center><img src=\\\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2dec359e3fb944c780f575462b3c4a57~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"image.png\\\"  width=\\\"30%\\\"/></p>\r\n\r\n然后就是另外两个圆和一些阴影效果，由于另外两个圆没有特殊的动效，所以在下使用两个`伪元素`来实现\r\n\r\n```css\r\n.eyeSocket::before,\r\n.eyeSocket::after {\r\n    content: \\\"\\\";\r\n    position: absolute;\r\n    top: 50%;\r\n    left: 50%;\r\n    transform: translate(-50%, -50%); // 居中\r\n    border-radius: 50%;\r\n    box-sizing: border-box; // css3盒子模型\r\n}\r\n.eyeSocket::before {\r\n    width: calc(100% + 20px);\r\n    height: calc(100% + 20px);\r\n    border: 6px solid #02ffff;\r\n}\r\n.eyeSocket::after {\r\n    width: 100%;\r\n    height: 100%;\r\n    border: 4px solid rgb(35, 22, 140);\r\n    box-shadow: inset 0px 0px 30px rgb(35, 22, 140);\r\n}\r\n```\r\n\r\n效果：\r\n\r\n<p align=center><img src=\\\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/271f55b6dd6e47c1a34ef73fb7d390d6~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"image.png\\\"  width=\\\"30%\\\"/></p>\r\n\r\n### 👀 画龙需点睛\r\n\r\n大眼的眼球画好了，之后就需要给它点上眼睛，喜欢什么样的眼睛因人而异，在下就选择这种`分割线`来作为大眼的眼仁。\r\n\r\n为了方便做一些过渡效果，在下使用`echarts`来完成这个眼仁。\r\n\r\n首先在下需要各位通过任何方式引入`echarts`库，然后给眼仁一个容器，并初始化`echarts`画布。\r\n\r\n```html\r\n<div class=\\\"eyeSocket\\\">\r\n    <div id=\\\"eyeball\\\"></div>\r\n</div>\r\n```\r\n\r\n```css\r\n#eyeball {\r\n    width: 100%;\r\n    height: 100%;\r\n}\r\n```\r\n\r\n```js\r\n// 画眼球\r\nlet eyeball = document.getElementById('eyeball'); // 获取eyeball元素\r\nlet eyeballChart = echarts.init(eyeball); // 初始化画布\r\nfunction getEyeballChart() {\r\n    eyeballChart.setOption({\r\n        series: [\r\n            {\r\n                type: 'gauge', // 使用仪表盘类型\r\n                radius: '-20%', // 采用负数是为了让分割线从内向外延伸\r\n                clockwise: false,\r\n                startAngle: '0', // 起始角度\r\n                endAngle: '270', // 结束角度\r\n                splitNumber: 3, // 分割数量，会将270度分割为3份，所以有四根线\r\n                detail: false,\r\n                axisLine: {\r\n                    show: false,\r\n                },\r\n                axisTick: false,\r\n                splitLine: {\r\n                    show: true,\r\n                    length: 12, // 分割线长度\r\n                    lineStyle: {\r\n                        shadowBlur: 20, // 阴影渐变\r\n                        shadowColor: 'rgb(0, 238, 255)', // 阴影颜色\r\n                        shadowOffsetY: '0',\r\n                        color: 'rgb(0, 238, 255)', // 分割线颜色\r\n                        width: 4, // 分割线宽度\r\n                    }\r\n                },\r\n                axisLabel: false\r\n            },\r\n            {\r\n                type: 'gauge',\r\n                radius: '-20%',\r\n                clockwise: false,\r\n                startAngle: '45', // 倾斜45度\r\n                endAngle: '315',\r\n                splitNumber: 3,\r\n                detail: false,\r\n                axisLine: {\r\n                    show: false,\r\n                },\r\n                axisTick: false,\r\n                splitLine: {\r\n                    show: true,\r\n                    length: 12,\r\n                    lineStyle: {\r\n                        shadowBlur: 20,\r\n                        shadowColor: 'rgb(0, 238, 255)',\r\n                        shadowOffsetY: '0',\r\n                        color: 'rgb(0, 238, 255)',\r\n                        width: 4,\r\n                    }\r\n                },\r\n                axisLabel: false\r\n            }\r\n        ]\r\n    })\r\n}\r\ngetEyeballChart();\r\n```\r\n\r\n效果： \r\n\r\n<p align=center><img src=\\\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/708787a3fd8c4f11ad371533a0541548~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"image.png\\\"  width=\\\"30%\\\"/></p>\r\n\r\n眼仁就这么轻轻松松的画好了，对于常用echarts的同学可以说是轻而易举，对吧。\r\n\r\n同时一个静态的大眼也创建完毕，接下来就要给大眼赋予生命了。\r\n\r\n> 再次提醒：长文，而且代码量多，建议抽思路看即可。\r\n\r\n### ✨ 生命仪式：休眠状态\r\n\r\n赋予生命是神圣的，她需要一个过程，所以在下从最简单的开始——**休眠状态**。\r\n\r\n在下给大眼设计的休眠状态，就是闭着眼睛睡觉，其实不露出眼仁同时有节奏的呼吸（缩放）罢了，相比于整个生命仪式来说，还是比较简单的，只需要修改大眼外框的大小即可。\r\n\r\n##### 呼吸\r\n\r\n这里在下采用的是`css转换+动画`的方式\r\n\r\n```html\r\n<div class=\\\"eyeSocket eyeSocketSleeping\\\">\r\n    <div id=\\\"eyeball\\\"></div>\r\n</div>\r\n```\r\n\r\n```css\r\n/* ...其他样式 */\r\n.eyeSocketSleeping {\r\n    animation: sleeping 6s infinite;\r\n}\r\n\r\n@keyframes sleeping {\r\n    0% {\r\n        transform: scale(1);\r\n    }\r\n\r\n    50% {\r\n        transform: scale(1.2);\r\n    }\r\n\r\n    100% {\r\n        transform: scale(1);\r\n    }\r\n}\r\n```\r\n\r\n<p align=center><img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/884c6529280b43a5993ee5eab06c31a1~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"sleeping.gif\\\"  width=\\\"30%\\\"/></p>\r\n\r\n##### 闭眼\r\n\r\n搞定了**呼吸**，但是睁着眼睛怎么睡得着？\r\n\r\n所以接下来在下要帮助大眼把眼睛闭上，这时候咱们前面给眼睛设置负数`radius`的好处就来了（**其实是在下设计好的**），因为`分割线`是从内向外延伸的，所以此时只需要慢慢减小分割线的高度，即可实现眼睛慢慢缩小的效果，即在下给大眼设计的闭眼效果。\r\n\r\n实现的效果是：大眼慢慢闭上眼睛（分割线缩小至0），然后开始**呼吸**\r\n\r\n直接上代码\r\n\r\n```html\r\n<div class=\\\"eyeSocket\\\" id='bigEye'> // 去掉 eyeSocketSleeping 样式，添加id\r\n    <div id=\\\"eyeball\\\"></div>\r\n</div>\r\n```\r\n\r\n```js\r\nlet bigEye = document.getElementById('bigEye'); // 获取元素\r\n// ...其他代码\r\nlet leftRotSize = 0; // 旋转角度\r\nlet ballSize = 12; // 眼睛尺寸\r\nlet rotTimer; // 定时器\r\n\r\nfunction getEyeballChart() {\r\n    eyeballChart.setOption({\r\n        series: [\r\n            {\r\n                startAngle: `${0 + leftRotSize * 5}`, // 加为逆时针旋转，乘5表示速度为leftRotSize的倍\r\n          \\tendAngle: `${270 + leftRotSize * 5}`, // 即变为每10微秒移动0.5度，1234678同理\r\n                // ...其他\r\n                splitLine: {\r\n                    length: ballSize, // 分割线高度设置为眼球尺寸变量\r\n                },\r\n            },\r\n            {\r\n                startAngle: `${45 + leftRotSize * 5}`,\r\n          \\t\\tendAngle: `${315 + leftRotSize * 5}`,\r\n                // ...其他\r\n                splitLine: {\r\n                    length: ballSize, // 同上\r\n                }\r\n            },\r\n            }\r\n        ]\r\n    })\r\n}\r\n// 休眠\r\nfunction toSleep() {\r\n    clearInterval(rotTimer); // 清除定时器\r\n    rotTimer = setInterval(() => {\r\n        getEyeballChart()\r\n        if (ballSize > 0) {\r\n            ballSize -= 0.1; // 当眼球存在时慢慢减小\r\n        } else {\r\n            bigEye.className = 'eyeSocket eyeSocketSleeping'; // 眼球消失后添加呼吸\r\n        }\r\n        leftRotSize === 360 ? (leftRotSize = 0) : (leftRotSize += 0.1); // 旋转，\r\n    }, 10);\r\n}\r\ngetEyeballChart();\r\ntoSleep()\r\n```\r\n\r\n> 旋转实现原理：（看过在下第一篇动效的同学对旋转的实现原理应该不陌生）\r\n>\r\n> **修改每个圈的起始角度（startAngle）和结束角度（endAngle），并不断刷新视图，** \r\n>\r\n> **增加度数为逆时针旋转，减去度数为顺时针旋转**\r\n\r\n如此一来就实现了眼睛缩小消失，然后开始呼吸的过程，同时咱们的大眼也进入了生命仪式之**休眠状态**（乱入的鼠标有点烦）；\r\n\r\n<p align=center><img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0b34439dc789482298da1ca1a4dd45a6~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"tosleep.gif\\\"  width=\\\"30%\\\"/></p>\r\n\r\n### ✨ 生命仪式：起床气状态\r\n\r\n在下相信，在座（站？蹲？）的各位同僚身边或者自身都存在一些小毛病，譬如咱们的大眼，它不但懒，喜欢睡觉，甚至叫醒它还会生气，通俗讲就是有**起床气**。\r\n\r\n心理学上说有种说法是：**情绪会让你接近生命的本真**。\r\n\r\n生命不就是情绪的结合嘛，没有情绪怎么能称之为生命的呢？\r\n\r\n在设计之前我们还有点准备工作，就是让大眼先处于**休眠状态**。\r\n\r\n```html\r\n<div class=\\\"eyeSocket eyeSocketSleeping\\\" id='bigEye'> // 添加休眠\r\n    <div id=\\\"eyeball\\\"></div>\r\n</div>\r\n```\r\n\r\n```js\r\n// ...其他代码\r\nlet ballSize = 0; // 初始眼球尺寸为0\r\n// ...其他代码\r\n// getEyeballChart(); // 把这两行删掉\r\n// toSleep() // 把这两行删掉\r\n```\r\n\r\n##### 唤醒\r\n\r\n然后我们需要唤醒大眼，所以首先我们需要添加**唤醒动作**——点击事件；\r\n\r\n```js\r\nlet bigEye = document.getElementById('bigEye'); // 获取元素\r\n// ...其他代码\r\nlet leftRotSize = 0;\r\nlet ballSize = 0;\r\nlet rotTimer;\r\nlet isSleep = true; // 是否处于休眠状态\r\n// 添加点击事件，当处于休眠状态时执行唤醒方法\r\nbigEye.addEventListener('click', () => {\r\n    if (!isSleep) return;\r\n    clickToWeakup();\r\n})\r\n// 唤醒\r\nfunction clickToWeakup() {\r\n    isSleep = false; // 修改状态\r\n    bigEye.className = 'eyeSocket'; // 清除休眠状态\r\n    clearInterval(rotTimer); // 清除定时器\r\n    rotTimer = setInterval(() => {\r\n        getEyeballChart()\r\n        ballSize <= 12 && (ballSize += 0.1);\r\n        leftRotSize === 360 ? (leftRotSize = 0) : (leftRotSize += 0.1);\r\n    }, 10);\r\n}\r\n```\r\n\r\n这样点一下大眼它就**苏醒**了过来：\r\n\r\n<p align=center><img src=\\\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/14b3283102414ef7ad4c8a1ecaf08924~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"toWeakup.gif\\\"  width=\\\"30%\\\"/></p>\r\n\r\n\r\n\r\n##### 生气\r\n\r\n**但是！**\r\n\r\n这是一个没有情绪的大眼，而在下需要的是一个有**起床气**的大眼，所以这样的大眼咱们不要！\r\n\r\n退格←...退格←...退格←...退格←...退格←...退格←......\r\n\r\n......\r\n\r\n慢点慢点，也不是全都不要了，咱们只需要修改一下他唤醒以后的操作，给他添加上**起床气**不就行了？\r\n\r\n接着来吧：\r\n\r\n首先我们把代表了大眼常态的**蓝色系**抽离出来，使用`css变量代替`，然后再苏醒后给他添加成代表生气的**红色系**\r\n\r\n```css\r\nbody {\r\n    width: 100vw;\r\n    height: 100vh;\r\n    overflow: hidden;\r\n    background-color: #111;\r\n    perspective: 1000px;\r\n    --c-eyeSocket: rgb(41, 104, 217);\r\n    --c-eyeSocket-outer: #02ffff;\r\n    --c-eyeSocket-outer-shadow: transparent;\r\n    --c-eyeSocket-inner: rgb(35, 22, 140);\r\n}\r\n.eyeSocket {\r\n    /* 其他属性 */\r\n    border: 4px solid var(--c-eyeSocket);\r\n    box-shadow: 0px 0px 50px var(--c-eyeSocket-outer-shadow); /* 当生气时添加红色外发光，常态则保持透明 */\r\n    transition: border 0.5s ease-in-out, box-shadow 0.5s ease-in-out; /* 添加过渡效果 */\r\n}\r\n.eyeSocket::before,\r\n.eyeSocket::after {\r\n    /* 其他属性 */\r\n    transition: all 0.5s ease-in-out; /* 添加过渡效果 */\r\n}\r\n.eyeSocket::before {\r\n    /* 其他属性 */\r\n    border: 6px solid var(--c-eyeSocket-outer);\r\n}\r\n.eyeSocket::after {\r\n    /* 其他属性 */\r\n    border: 4px solid var(--c-eyeSocket-inner);\r\n    box-shadow: inset 0px 0px 30px var(--c-eyeSocket-inner);\r\n}\r\n```\r\n\r\n```js\r\n// ...其他代码\r\nlet ballColor = 'transparent'; // 默认透明，其实默认是啥都无所谓，反正看不见\r\n\r\nfunction getEyeballChart() {\r\n    eyeballChart.setOption({\r\n        series: [\r\n            {\r\n                // ...其他\r\n                splitLine: {\r\n                    // ...其他\r\n                    lineStyle: {\r\n                        // ...其他\r\n                        shadowColor: ballColor, // 把眼睛的眼影颜色设为变量控制\r\n                        color: ballColor,\r\n                    }\r\n                },\r\n            },\r\n            {\r\n                // ...其他\r\n                splitLine: {\r\n                    // ...其他\r\n                    lineStyle: {\r\n                        // ...其他\r\n                        shadowColor: ballColor,\r\n                        color: ballColor,\r\n                    }\r\n                }\r\n            },\r\n            }\r\n        ]\r\n    })\r\n}\r\n// 生气模式\r\nfunction setAngry() {\r\n    // 通过js修改body的css变量\r\n    document.body.style.setProperty('--c-eyeSocket', 'rgb(255,187,255)');\r\n    document.body.style.setProperty('--c-eyeSocket-outer', 'rgb(238,85,135)');\r\n    document.body.style.setProperty('--c-eyeSocket-outer-shadow', 'rgb(255, 60, 86)');\r\n    document.body.style.setProperty('--c-eyeSocket-inner', 'rgb(208,14,74)');\r\n    ballColor = 'rgb(208,14,74)';\r\n}\r\n// 常态模式\r\nfunction setNormal() {\r\n    document.body.style.setProperty('--c-eyeSocket', 'rgb(41, 104, 217)');\r\n    document.body.style.setProperty('--c-eyeSocket-outer', '#02ffff');\r\n    document.body.style.setProperty('--c-eyeSocket-outer-shadow', 'transparent');\r\n    document.body.style.setProperty('--c-eyeSocket-inner', 'rgb(35, 22, 140)');\r\n    ballColor = 'rgb(0,238,255)';\r\n}\r\n// 唤醒\r\nfunction clickToWeakup() {\r\n    isSleep = false;\r\n    bigEye.className = 'eyeSocket';\r\n    setAngry(); // 设置为生气模式\r\n    clearInterval(rotTimer);\r\n    rotTimer = setInterval(() => {\r\n        getEyeballChart()\r\n        ballSize <= 50 && (ballSize += 1);\r\n        leftRotSize === 360 ? (leftRotSize = 0) : (leftRotSize += 0.5);\r\n    }, 10);\r\n}\r\n// 点击\r\nbigEye.addEventListener('click', () => {\r\n    if (!isSleep) return;\r\n    clickToWeakup();\r\n})\r\n```\r\n\r\n大眼生气长这样：\r\n\r\n<p align=center><img src=\\\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a51a1cfbd5f044d58a06d4e4cca46193~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"angry.gif\\\"  width=\\\"30%\\\"/></p>\r\n\r\n##### 更生气\r\n\r\n不知道在座（站？蹲擦？）各位是如何看待，但是在下看来，大眼这样好像还不够生气。\r\n\r\n没错还不够生气，如何让大眼起来更生气呢，生气到**发火**如何？\r\n\r\n嗦干酒干！\r\n\r\n在下这里采用的是`svg滤镜`的方法，`svg滤镜`的属性和使用方法非常繁多，在下使用得也不是很娴熟，本文中在下就不赘述了，网上冲浪有许多技术大牛讲的非常好，希望各位勉励自己。emmmm......**然后来教会在下，记得给在下留言文章地址**\r\n\r\n在下使用的是`feTurbulence`来形成噪声，然后用`feDisplacementMap`替换来给大眼添加粒子效果，因为`feDisplacementMap`会混合掉元素，所以在下需要给大眼新增一个大眼替身来代替大眼被融合。\r\n\r\n**创建大眼替身**\r\n\r\n```html\r\n<div class=\\\"filter\\\"> // 添加滤镜的元素\r\n    <div class=\\\"eyeSocket\\\" id='eyeFilter'> // 大眼替身\r\n    </div>\r\n</div>\r\n```\r\n\r\n```css\r\n.filter {\r\n    width: 100%;\r\n    height: 100%;\r\n}\r\n.eyeSocket,\r\n.filter .eyeSocket { /* 给替身加上相同的样式 */\r\n    /* ...原属性 */\r\n}\r\n```\r\n\r\n<p align=center><img src=\\\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/876c4b4e0fc0471f8136837d9845979c~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"image.png\\\"  width=\\\"30%\\\"/></p>\r\n\r\n**融合**\r\n\r\n```html\r\n<div class=\\\"filter\\\">\r\n    <div class=\\\"eyeSocket\\\" id='eyeFilter'>\r\n    </div>\r\n</div>\r\n<!-- Svg滤镜 -->\r\n<svg width=\\\"0\\\">\r\n    <filter id='filter'>\r\n        <feTurbulence baseFrequency=\\\"1\\\">\r\n            <animate id=\\\"animate1\\\" attributeName=\\\"baseFrequency\\\" dur=\\\"1s\\\" from=\\\"0.5\\\" to=\\\"0.55\\\" begin=\\\"0s;animate1.end\\\">\r\n            </animate>\r\n            <animate id=\\\"animate2\\\" attributeName=\\\"baseFrequency\\\" dur=\\\"1s\\\" from=\\\"0.55\\\" to=\\\"0.5\\\" begin=\\\"animate2.end\\\">\r\n            </animate>\r\n        </feTurbulence>\r\n        <feDisplacementMap in=\\\"SourceGraphic\\\" scale=\\\"50\\\" xChannelSelector=\\\"R\\\" yChannelSelector=\\\"B\\\" />\r\n    </filter>\r\n</svg>\r\n```\r\n\r\n```css\r\n.filter {\r\n    width: 100%;\r\n    height: 100%;\r\n    filter: url('#filter'); /* 开启滤镜 */\r\n}\r\n```\r\n\r\n<p align=center><img src=\\\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8aabd1930e8549a8b4e29bf2c98c6c9c~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"copy.gif\\\" width=\\\"30%\\\" /></p>\r\n\r\n芜湖~果然献祭了一只“大眼”出来的效果看起来确实还不错哈？确实看起来酷炫多了，不愧是**“献祭”**啊！\r\n\r\n**真眼出现**\r\n\r\n既然粒子效果已经产生，咱们的真实大眼也就不需要躲躲藏藏了，该站出来获取这粒子“光环”了！\r\n\r\n大眼：哈！\r\n\r\n<p align=center><img src=\\\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/01fe7e71859043fcbd1fddea32b74450~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"fire.gif\\\" width=\\\"30%\\\" /></p>\r\n\r\n额......\r\n\r\n其实......\r\n\r\n也挺好看的嘛，不是吗？毕竟不是献祭的真正的大眼，毕竟是个替身，效果没有本体好也是很正常的对吧。\r\n\r\n> 本质上是因为`feDisplacementMap`设置了`scale`属性的原因。\r\n>\r\n> `feDisplacementMap`其实就是一个位置替换滤镜，通过就是改变元素和图形的像素位置的进行重新映射，然后替换一个新的位置，形成一个新的图形。\r\n>\r\n> 而`scale`就是替换公式计算后偏移值相乘的比例，影响着图形的偏移量和呈现的效果。\r\n\r\n但是话虽如此，咱这个光环不能真的就这么戴着呀，咱们还需要对光环的位置进行一些微调。\r\n\r\n```css\r\n.filter .eyeSocket {\r\n    left: calc(50% - 92px);\r\n    top: calc(50% - 92px);\r\n}\r\n```\r\n\r\n<p align=center><img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5036ed8d0904110af4d5aa0859de57b~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"goodfire.gif\\\"  width=\\\"30%\\\"/></p>\r\n\r\n\r\n\r\n看看，看看！这不就顺眼多了吗，献祭了替身，所以尺寸都是非常契合的，而且共用了样式，所以当大眼**生气**的时候，光环也会跟着生气。\r\n\r\n这下光环也有了，看起来的确比之前更生气了。\r\n\r\n但是我们还需要对大眼做一些细微的调整，因为大眼在常规状态下并不需要这个光环，睡着的时候光环在旁边“滋啦滋啦”不吵的慌么，所以我们还需要把常态下的大眼光环给消除掉。\r\n\r\n在下采用的是不透明度`opacity`来控制，当大眼处于生气状态时，光环为不透明；处于常规状态时光环透明不可见。\r\n\r\n```css\r\n.filter .eyeSocket {\r\n    opacity: 0; // 默认状态下不透明度为0\r\n    left: calc(50% - 92px);\r\n    top: calc(50% - 92px);\r\n    transition: all 0.5s ease-in-out; // 添加过渡效果，值得注意的是不能丢了原本的过渡效果，所以这里使用all\r\n}\r\n```\r\n\r\n```js\r\n// ...其他代码\r\nlet eyeFilter = document.getElementById('eyeFilter'); // 获取元素\r\n// 唤醒\r\nfunction clickToWeakup() {\r\n    eyeFilter.style.opacity = '1'; // 不透明度设为1\r\n    // ...其他\r\n}\r\ndeathEye.addEventListener('click', () => {\r\n    if (!isSleep) return;\r\n    clickToWeakup();\r\n})\r\n```\r\n\r\n这样设置完，一个更生气的大眼就这样出现了：\r\n\r\n<p align=center><img src=\\\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1ecedf4f79d4408f862e581ce1228a98~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"moreAngry.gif\\\"  width=\\\"30%\\\"/></p>\r\n\r\n**更更生气**\r\n\r\n不知看到这样**发火**的大眼，各位是不是已经满足于此。\r\n\r\n但是在下认为不，在下觉得一个真正足够生气的大眼，不只局限于自己生气，还需要找人发泄！！\r\n\r\n所以在下还给大眼添加了一些大眼找人的动效（当然是找不到的，它这么笨）。\r\n\r\n其实就是让大眼左右旋转，通过`css转换`来实现。\r\n\r\n```html\r\n<div class=\\\"eyeSocket eyeSocketSleeping\\\" id='bigEye'>\r\n    <div id=\\\"eyeball\\\"></div>\r\n</div>\r\n<div class=\\\"filter\\\">\r\n    <div class=\\\"eyeSocket\\\" id='eyeFilter'>\r\n    </div>\r\n</div>\r\n<!-- Svg滤镜 -->\r\n<svg width=\\\"0\\\">\r\n    ...\r\n</svg>\r\n```\r\n\r\n\r\n\r\n```css\r\n/* ...其他样式 */\r\nbody {\r\n    /* ...其他属性 */\r\n    perspective: 1000px;\r\n}\r\n.eyeSocketLooking {\r\n    animation: lookAround 2.5s; // 添加动画，只播放一次\r\n}\r\n/* 环视动画 */\r\n@keyframes lookAround {\r\n    0% {\r\n        transform: translateX(0) rotateY(0);\r\n    }\r\n\r\n    10% {\r\n        transform: translateX(0) rotateY(0);\r\n    }\r\n\r\n    40% {\r\n        transform: translateX(-70px) rotateY(-30deg);\r\n    }\r\n\r\n    80% {\r\n        transform: translateX(70px) rotateY(30deg);\r\n    }\r\n\r\n    100% {\r\n        transform: translateX(0) rotateY(0);\r\n    }\r\n}\r\n```\r\n\r\n```js\r\n// ...其他代码\r\nlet bigEye = document.getElementById('bigEye'); // 获取元素\r\nlet eyeFilter = document.getElementById('eyeFilter'); \r\n\r\n// 唤醒\r\nfunction clickToWeakup() {\r\n    // ...其他代码\r\n    eyeFilter.className = bigEye.className = 'eyeSocket eyeSocketLooking'; // 同时给大眼和光环添加环视动画\r\n}\r\n\r\nbigEye.addEventListener('click', () => {\r\n    if (!isSleep) return;\r\n    clickToWeakup();\r\n})\r\n```\r\n\r\n看看大眼在找什么？\r\n\r\n<p align=center><img src=\\\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5aa61c221650457b95ae80455369558e~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"lookaround.gif\\\"  width=\\\"70%\\\"/></p>\r\n\r\n> 向左看时，Y轴偏移量为-70px，同时按Y轴旋转-30°\r\n>\r\n> 向右看时，Y轴偏移量为70px，同时Y轴旋转30°\r\n\r\n### ✨ 生命仪式：自我调整状态\r\n\r\n这个状态非常好理解，大眼虽然有**起床气**，但是也仅限于起床对吧，总不能一直让它生气，气坏了咋办，带着情绪工作，效果也不好不是吗。\r\n\r\n所以我们还需要给它一点时间，让它自我调整一下，恢复成正常状态。\r\n\r\n这个**自我调整状态**就是一个从生气状态变回常态的过程，在这个过程中，大眼需要将生气状态的红色系切换为常态的蓝色系，同时**红眼**也会慢慢褪去恢复正常。\r\n\r\n其实这个**自我调整状态**还是属于唤醒状态中，只是需要放在**起床气状态**之后。\r\n\r\n这里在下采纳了上文中有位同学给的建议，监听动画结束事件`webkitAnimationEnd`，然后将**自我调整**放在动画结束以后。\r\n\r\n同时这里也有两个步骤：\r\n\r\n1. 退出**起床气状态**；\r\n2. 变回常态\r\n\r\n为了保证两个步骤的先后顺序，可以使用`Promise`来实现。不懂`Promise`的同学可以先去学习一下，在下也讲不清楚哈哈哈哈。\r\n\r\n```js\r\n// ...其他代码\r\nbigEye.addEventListener('webkitAnimationEnd', () => { // 监听动画结束事件\r\n    new Promise(res => {\r\n        clearInterval(rotTimer); // 清除定时器\r\n        rotTimer = setInterval(() => {\r\n            getEyeballChart(); // 更新视图\r\n            ballSize > 0 && (ballSize -= 0.5); // 眼球尺寸减小\r\n            leftRotSize === 360 ? (leftRotSize = 0) : (leftRotSize += 0.1);\r\n            if (ballSize === 0) { // 当眼球尺寸为0时，将Promise标记为resolved，然后执行后面的代码\r\n                clearInterval(rotTimer);\r\n                res();\r\n            }\r\n        }, 10);\r\n    }).then(() => {\r\n        eyeFilter.style.opacity = '0'; // 清除光环\r\n        eyeFilter.className = bigEye.className = 'eyeSocket'; // 清除环视动画\r\n        setNormal(); // 设置常态样式\r\n        rotTimer = setInterval(() => {\r\n            getEyeballChart();\r\n            ballSize <= 12 && (ballSize += 0.1); // 眼球尺寸缓慢增加\r\n            leftRotSize === 360 ? (leftRotSize = 0) : (leftRotSize += 0.1);\r\n        }, 10);\r\n    })\r\n})\r\n```\r\n\r\n添加了这样一个监听事件后，咱们的大眼就已经具备了自我调整的能力了：\r\n\r\n<p align=center><img src=\\\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3af09618a4514bfabded2ddf960fc4d4~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"back.gif\\\"  width=\\\"70%\\\"/></p>\r\n\r\n### ✨ 生命仪式：工作状态\r\n\r\n接下来就到了大眼重中之重的环节，也就是大眼的**工作状态**。\r\n\r\n在下给大眼的工作非常简单，就是单纯的盯住在下的鼠标，如果各位想给各自的大眼一些其他的功能，可以自己发挥。\r\n\r\n盯住鼠标，不只是说说而已，那么怎么样才能让大眼表现出他已经盯住了呢？\r\n\r\n在下的思路是：\r\n\r\n1. 以大眼的位置为原点建立一个直角坐标系\r\n2. 然后通过监听鼠标移动事件，获取鼠标所在位置，计算出鼠标处于大眼坐标系的坐标。\r\n3. 将整个视口背景以X轴和Y轴进行等分成无数个旋转角度，通过鼠标坐标的数值和正负来**调整大眼眼框和眼睛的Y轴和Z轴旋转**，从而达到盯住鼠标的目的。\r\n\r\n好的，咱们理清思路，接下来就是付诸于行动。\r\n\r\n```js\r\n// ...其他代码\r\n// 工作\r\nfunction focusOnMouse(e) {\r\n    {\r\n        // 视口尺寸，获取到整个视口的大小\r\n        let clientWidth = document.body.clientWidth;\r\n        let clientHeight = document.body.clientHeight;\r\n        // 原点，即bigEye中心位置，页面中心\r\n        let origin = [clientWidth / 2, clientHeight / 2];\r\n        // 鼠标坐标\r\n        let mouseCoords = [e.clientX - origin[0], origin[1] - e.clientY];\r\n\\t\\t// 旋转角度\r\n        let eyeXDeg = mouseCoords[1] / clientHeight * 80; // 这里的80代表的是最上下边缘大眼X轴旋转角度\r\n        let eyeYDeg = mouseCoords[0] / clientWidth * 60;\r\n        bigEye.style.transform = `rotateY(${eyeYDeg}deg) rotateX(${eyeXDeg}deg)`;\r\n        eyeball.style.transform = `translate(${eyeYDeg / 1.5}px, ${-eyeXDeg / 1.5}px)`;\r\n    }\r\n}\r\n```\r\n\r\n> 注意： 如果觉得旋转角度不够大，可以调整代码中的`80`和`60`，最大可以到180，也就是完全朝向，但是由于大眼终归是一个平面生物，如果旋转度数过大，就很容易穿帮，如果旋转角度为180，大眼就会在某个方向完全消失看不见（因为大眼没有厚度，这个也许是可以优化的点），所以个人喜好调整吧。\r\n\r\n咱们来看看大眼工作时的飒爽英姿：\r\n\r\n<p align=center><img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f87570020bf94bc5a43406881b6957b9~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"watching.gif\\\"  width=\\\"70%\\\"/></p>\r\n\r\n### ✨ 生命仪式：懒惰状态\r\n\r\n顾名思义，**懒惰状态**就是......懒惰状态。\r\n\r\n在下给大眼设计的懒惰状态就是当在下的鼠标超过`30秒`没有移动时，大眼就会进入**休眠状态**。\r\n\r\n所以**生命仪式**的最后收尾其实非常的轻松，没有大量的代码，只需要添加一个定时器，然后修改**休眠状态**的代码，将大眼的所有参数初始化即可。\r\n\r\n```js\r\n// ...其他代码\r\nlet sleepTimer; // 休眠定时器\r\n\r\n// 休眠\r\nfunction toSleep() {\r\n    // ...其他操作\r\n    document.body.removeEventListener('mousemove', focusOnMouse); // 移除鼠标移动事件\r\n    bigEye.style.transform = `rotateY(0deg) rotateX(0deg)`; // 大眼归位\r\n    eyeball.style.transform = `translate(0px, 0px)`; // 眼睛归位\r\n}\r\n// 工作\r\nfunction focusOnMouse(e) {\r\n    // ...其他操作\r\n    // 设置休眠\r\n    if (sleepTimer) clearTimeout(sleepTimer); // 如果休眠定时器已经被设置，则清除休眠定时器\r\n    sleepTimer = setTimeout(() => { // 重新计时\r\n        toSleep();\r\n    }, 30000);\r\n}\r\n```\r\n\r\n**感谢上次掘金官方的提醒，在下把线上代码贴在这，在下文笔较差，看不下去的同学可以直接过来玩一玩，感兴趣再去创建自己的大眼。（没有点运行的不要来问我为什么出不来！！！）**\r\n\r\n[代码片段](https://code.juejin.cn/pen/7132406758995132428)\r\n\r\n**如果自己在码上掘金动手的同学记得不要忘记添加echarts资源**\r\n\r\n<p align=center><img src=\\\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c21c5ea9b013448e959e0ad89971d05b~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"image.png\\\" width=\\\"100%\\\" /></p>\r\n\r\n\r\n\r\n### 💐 结语\r\n\r\n好家伙，原来再写一遍大眼会这么累，这次是真真正正的“玩”了一天，有功夫的各位同僚也可以去玩一玩，于在下的基础上进行完善，创造出属于各位自己的大眼。当然如果有一些比较好玩的动效也可以留言告知在下，当下次混工作量时在下可以有东西写。\r\n\r\n就这样！\r\n\r\n<p align=center><img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6dd3ca20336e4e50ba42cc50bb1d25ab~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"image.png\\\"  width=\\\"50%\\\"/></p>\r\n\r\n\r\n\r\n\r\n"
    },
    {   "snapshot": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8f92f5b6e10e41a5a66fe7b6a007401a~tplv-k3u1fbpfcp-watermark.image?",
        "title": "如何应对核心员工提离职？",
        "preview": "最近一年互联网行情不好，很多大厂都在裁员，但裁员并不是不要人做事了。原来你这个岗位10个人做，企业有钱赚养得起，现在企业不怎么赚钱了，只能养4个人了。那么会有六个被裁掉。",
        "author": "石云升",
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/6c635cfd69c6df18e557000fe4719e2e~300x300.image",
        "content": "---\r\ntheme: channing-cyan\r\n---\r\n我报名参加金石计划1期挑战——瓜分10万奖池，这是我的第6篇文章，[点击查看活动详情](https://juejin.cn/post/7138637426922094605 \\\"https://juejin.cn/post/7138637426922094605\\\")\r\n\r\n最近一年互联网行情不好，很多大厂都在裁员，但裁员并不是不要人做事了。原来你这个岗位10个人做，企业有钱赚养得起，现在企业不怎么赚钱了，只能养4个人了。那么会有六个被裁掉。这时候对企业价值最大的4个人会被留下。也许因为人更少了，反而工资还会有所提升。\r\n\r\n越是大公司，人员越冗余。开掉一批人对项目进度影响其实不大。但如果掌握核心技术的员工离职，可能项目真的就黄了。\r\n\r\n我朋友老张最近就跟我抱怨他公司技术能力最强的哥们要离职。根据他的描述，这离职的哥们属于1个打10个那种。公司里有些问题只有他能解决，公司一直想要培养个接班人，但大多数都只学到了点皮毛。现在就问我该怎么办？所以，今天就和大家聊聊这个话题。\r\n\r\n企业最怕的就是最优秀的那批员工离职。而且这部分人只要提了离职基本上就很难挽回了。\r\n\r\n## 为什么会离职？\r\n\r\n为什么环境这么差，还有人会主动离职？因为环境再差，总有一些企业还在招人，越是对能力要求高的岗位，越难招。所以，那些真正优秀的人才是不用担心工作问题的。\r\n\r\n马云曾说员工提离职，就两个原因，钱给少了，或者心受委屈了。其实还有一类，是工作不能给自己带来成长了。 很多人对工作追求的是成长，是获得尊重、获得一些更高级的意义。你想要挽回对方，首先得弄清楚对方离职的原因。不过这种时候，大概率已经找我下家了。\r\n\r\nPS：绝不建议大家裸辞，除非你是准备离职后休息两月。但就算要休息两月，也记得找人把社保交了，别断社保哈。\r\n\r\n## 能不能留下来？\r\n\r\n不管对方是否找好下家，作为公司管理者还是要去做努力争取对方留下，万一对方还没有跟下家确定好，只是有意向呢？所以在对方提出离职后，不要去做正式离职沟通。先找理由拒绝，然后约个时间私下里做一次沟通。可以找个地方，边吃饭边聊天。\r\n\r\n在这个私下沟通的场景下要表示不希望对方离开，要是遇到了什么难处可以如实说。如果是薪资这块问题，差别太大你可能拿不定主意。但如果是因为什么工作太忙，家里事情很多这类问题。完全可以拍板让对方调整工作时间。\r\n\r\n这里我讲一个案例，以前有个朋友跟我说，公司太卷了，最近感觉身体不行了。所以准备离职换个轻松点的工作环境？我说：“啥叫轻松点的工作环境”\r\n\r\n他说：\\\"每天能正常下班，不用经常加班熬夜。这样我就能有更多时间睡觉，还能抽出一部分时间出来健身啥的。\\\"\r\n\r\n我问：“那为什么不在现在公司里就调整下工作时间呢？”\r\n\r\n他说：\\\"公司这么忙，我要这么做，老板估计也会开了我的\\\"。\r\n\r\n我反问说：“你都要离职了，还怕他辞退啊”\r\n\r\n就这样过了一年，对方也没离职，工作也没耽误。工作时间越长并不表示工作效率越高。我真的建议很忙的人能抽出一部分时间来冥想，每天10多分钟就行，让自己脑袋空一下。你会获得很多不一样的收获。\r\n\r\n## 需要我做什么？\r\n\r\n如果对方已经下定决定要走了，那么还可以问对方，现在自己能够做点什么。如果对方希望早点走完流程，那就帮忙让流程走快点。当然，流程走快了，后面接手人肯定会有问题还会请教你，这点可以直接说。\r\n\r\n如果对方对未来也有迷茫，有犹豫。那么作为管理者，你肯定也有着丰富的见识，在自己能力范围内的话，帮助对方去分析利弊，提供建议参考。\r\n\r\n员工离职，特别是核心员工离职，管理者可能会有点生气。毕竟会影响到自己的项目。但把格局放大，未来就没有再合作的机会？现在很少一个人会在公司呆一辈子。人来人走是平常。现在离开，未必不会再回来。虽然现在留不住人，但我可以留心。你以真诚待人，别人也会真诚待你。\r\n\r\n我记得在《联盟》这本书里说过，很多大公司都有前员工联盟，公司里有专门人进行管理。好处很多。\r\n\r\n首先前员工可以为企业带来声誉和良好的社会效应；\r\n\r\n其次前员工可以给企业引进人才；\r\n\r\n再次前员工还能给企业带来更多新的行业信息。\r\n\r\n甚至公司一些新的产品都可以给到前员工试用，你找其他人还需要培训，前员工就不需要。\r\n\r\n对于我们自己来说，我们是一起战斗过的战友。不管企业有没有正式组织，都应该常联系。\r\n\r\n## 有什么办法能避免核心员工提离职？\r\n\r\n### 1. 上工治未病，最好的方法就是不给对方提离职的机会。\r\n\r\n离职过的人都知道，从想离职到提出离职，中间是有很长的时间的。而且在这个过程中，总会露出一些异常的行为。比如，开始抱怨公司的某件事情；在一些以前经常发表建议的场景下，变得不爱沟通，该怎样就怎样吧；工作没精神，不再主动推进某些工作等等。反正总会有点异常。作为管理者，如果你不能提前发生这些异常，那是失职了。你可以说自己很忙，但再怎么忙，都要抽出时间来关注这些核心员工。不仅仅是工作状态，还有家庭状态。你要是真关心员工，什么问题都好解决。\r\n\r\n### 2. 把核心员工跟项目收益做强绑定，增加离职成本。\r\n\r\n管理者不仅要会画饼，还要会分饼。如何分饼决定了饼的大小。既然都说对方是核心员工了，那么就应该让对方享受到同样的待遇。公司现在没这么多钱没关系，拿出部分期权、股权总可以吧。做成了，大家一起赚钱，失败了，是我们没做好，咱也认。\r\n\r\n### 3. 核心员工要离职创业？行。我投资\r\n\r\n核心员工如果愿意舍弃这么好的收益去创业，那么作为公司为什么就不能参与进去呢？既然挡不住，那我就不挡了。我大大方方的把投资方案公布出来。你想离职创业？可以，有好项目，我们公司愿意做你的天使投资人。如果项目真的好，那么公司赚了。如果项目不好，帮对方分析弊端，也许对方就不离职了。都是好事。\r\n"
    },
    {   "snapshot": "",
        "title": "这10 个很“哇塞”的Web资源，前端必备的神仙级网站",
        "preview": "毋庸置疑，善用工具可以加速开发，拉满开发效率，减少996的频率，提高我们的生活质量。 在此，为前端工友们分享10个我压箱底的Web资源，收藏≠学会，赶紧用起来吧！ 1.Github （https://",
        "author": "摹客",
        "avatar": "https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/6/11/163ecafe1172d9bf~tplv-t2oaga2asx-image.image",
        "content": "毋庸置疑，善用工具可以加速开发，拉满开发效率，减少996的频率，提高我们的生活质量。\r\n\r\n在此，为前端工友们分享10个我压箱底的Web资源，收藏≠学会，赶紧用起来吧！\r\n\r\n  \r\n\r\n  \r\n\r\n1.Github\r\n========\r\n\r\n（[https://github.com/](https://github.com/)）\r\n\r\n咱们普通人空闲时会想着刷刷朋友圈、微博、知乎来放松，然而大佬就不一样了，他们没事就逛逛Github。在日积月累中，这差距自然越来越大！\r\n\r\n其实，在我看来，初级工友和高级工友之间，最大的差距或许就是信息差导致的。\r\n\r\n逛逛Github，每天看看又开源了哪些好的前端项目，还有用到的主流前端技术栈又是什么，久而久之，多看多学，你的前端水平也会不断精进。\r\n\r\n网上有不少人分享从Github上扒下来超火的面试项目、CSS技巧项目等资源，在此我就不过多赘述了。\r\n\r\n总之，说起Github，咱们都耳熟能详，但每天或每周定时去逛逛，才是真道理！\r\n\r\n![图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a1f3eae16ff4e35969be0a230866651~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n  \r\n\r\n\r\n\r\n\r\n2.Github镜像源网站\r\n=============\r\n\r\n作为国内用户，我听很多工友都吐槽过访问Github很慢很慢，再加上访问Github需要科学上网，这又难倒了一群英雄好汉。\r\n\r\n所以，在这里给大家分享几个Github镜像源网站，亲测好用！\r\n\r\n*   [https://hub.fastgit.xyz](https://hub.fastgit.xyz)\r\n    \r\n*   [https://cdn.githubjs.cf/](https://cdn.githubjs.cf/)\r\n    \r\n*   [https://gitclone.com/](https://gitclone.com/)（仅支持git）\r\n    \r\n*   [https://hub.fastgit.xyz/](https://hub.fastgit.xyz/)（支持git）\r\n    \r\n\r\n3.Undraw\r\n========\r\n\r\n（[https://undraw.co/](https://undraw.co/)）\r\n\r\n在开发过程中，如果需要免费的SVG插图，那你一定不要错过Undraw！\r\n\r\n ![图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d3742a7ac1e409797ff0bdc96161a6d~tplv-k3u1fbpfcp-zoom-1.image) \r\n\r\nUndraw中包含了数百张风格一致的扁平化插画，在很多场合中，应用起来都毫无违和感。\r\n\r\n在挑选时，你除了可以一直往下滑以外，还可以在搜索框中输入关键字。\r\n\r\nUndraw默认提供了6种配色方案，也可以自定义颜色，下载支持PNG和SVG两种格式，均能免费商用，简直不要太NICE！\r\n\r\n ![图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f69c9ffac944f3aa2e929da36cf2a8b~tplv-k3u1fbpfcp-zoom-1.image) \r\n\r\n\r\n\r\n4.Errow404\r\n==========\r\n\r\n（[https://error404.fun/](https://gitclone.com/)）\r\n\r\n当网站出现严重BUG或当用户输入错误网址时，总会有弹出404页面。\r\n\r\n如今404页面设计越来越具有创意性，例如Figma，在设计过程中，网页崩了？！没关系，404界面有拖拽的圆点，继续画呗，反正不耽误生产力！\r\n\r\n ![图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f4d029c085fc4d668a086ede5f8a4271~tplv-k3u1fbpfcp-zoom-1.image) \r\n\r\n看着这么多有意思的404界面，咱们务必得“卷”起来~所以，给大家安利一个找404页面素材的网站：Errow404。\r\n\r\n在开发时，给插画再加上炫酷动效，令人兴奋的404页面不就搞定了吗！\r\n\r\n![图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35482803dab04e9a907b4b25f5baa7d2~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n  \r\n\r\n\r\n5.VueFastDev\r\n============\r\n\r\n（[https://www.npmjs.com/package/vuefastdev](https://www.npmjs.com/package/vuefastdev)）\r\n\r\nVueFastDev是一套基于element-ui、Echarts等二次开发封装、模块化的前端UI组件库。\r\n\r\n它是一个低代码的前框框架，它使用JSON配置生成页面，可以减少我们的页面开发工作量，从而提升效率。\r\n\r\n ![图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b2fda7623d34eff9ed755ce870a1d70~tplv-k3u1fbpfcp-zoom-1.image) \r\n\r\n除了低代码模式外，VueFastDev还可以自动以组件来扩充组件，实际上VueFastDev可以当成普通UI库来使用，实现90%低代码操作环境！\r\n\r\n  \r\n\r\n  \r\n\r\n6.Shape Divider\r\n===============\r\n\r\n（[https://www.shapedivider.app/](https://www.shapedivider.app/)）\r\n\r\n为了让页面能整洁美观，相信各位工友没少用分割线处理吧。\r\n\r\nShape Divider是一款免费的Web应用程序，使用自定义代码就能快速导出精美的预制SVG格式的形状分割器。\r\n\r\n选择分割线的形状、颜色、高度、宽度，勾选是否翻动、倒置、顶部/底部设置即可，半分钟就能轻松搞定一个精美的形状分割器！\r\n\r\n ![图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1bb3afe847c9436989f93c0446142c66~tplv-k3u1fbpfcp-zoom-1.image) \r\n\r\n  \r\n\r\n\r\n7.摹客\r\n====\r\n\r\n（[https://www.mockplus.cn/idoc/developer](https://www.mockplus.cn/idoc/developer/?hmsr=juejin)）\r\n\r\n想问各位工友一句：你们公司UI有没有经常找你掰扯还原度低的问题？\r\n\r\n一会因为标注，一会又因为切图，大半天的时间都耗在跟UI的沟通对接上，开发效率能提起来才是怪事！\r\n\r\n但自从我们公司UI用摹客交付设计稿后，每天找他扯皮的时间少了很多，双方都乐得清净。\r\n\r\n![图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/21305d638f434097904a129b7387d7ab~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n现在，UI也无需再给我打包切图文件，我直接在摹客中就能自主切换平台（iOS/Android/Web）、选择倍率、下载不同格式（PNG/WebP/SVG/JPG）的切图。\r\n\r\n而且还能提前将切图压缩好后再打包下载，省时省力，提高开发效率！\r\n\r\n![图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b0b225b0eee24f91a530b18dcf987e9f~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n标注也能在设计稿中自动获取，甚至连设计稿中的图层样式，都能在摹客中一键复制。该说不说，在团队协作这一块，摹客真的赢麻了！\r\n\r\n ![图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f9ac11ca514a433abdea5d64697daba7~tplv-k3u1fbpfcp-zoom-1.image) \r\n\r\n  \r\n\r\n\r\n8.语雀\r\n====\r\n\r\n（[https://www.yuque.com/](https://www.yuque.com/)）\r\n\r\n现在越来越多的碎片化信息充斥着我们的生活，公众号文章、社区论坛帖子、知乎问答、抖音视频……\r\n\r\n虽然我们接收着这么多的信息，但真正被我们沉淀下来，转化为自身能力的知识又有多少呢？\r\n\r\n所以，给大家推荐一个文档和知识协同工具：语雀。\r\n\r\n个人笔记、待办List、生活备忘录、会议记录、项目文档、需求管理……无论是个人笔记，还是团队资料，都能在语雀中得到整理归纳。将这一系列的内容整合后，就是我们自身的一笔财富！\r\n\r\n![图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9353492aeae149d5b25b0e29de2a5a43~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n  \r\n\r\n9.阿里巴巴矢量图标库\r\n===========\r\n\r\n（[https://www.iconfont.cn/](https://www.iconfont.cn/)）\r\n\r\n项目需要紧急上线时，UI连图标icon都没画出来，要你自己先想办法搞定，这事你遇到过没？\r\n\r\n其实这事没那么复杂，iconfont中提供了海量的矢量图标合集，为大家提供了图标下载、在线存储、格式转换等功能。\r\n\r\n![图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/83a36bdaed2d4c118d0046f332597602~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n不愧是阿里巴巴团队倾力打造，图标的质量都很高。\r\n\r\n图标支持AI/SVG/PNG/代码格式下载，所以，即使前端工友们不会设计，也能下载了图标后直接拿来就用，相当高效！\r\n\r\n![图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/34948fdc7eaf4b14bb4cc74409de0e65~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n  \r\n\r\n10.Microsoft To Do\r\n==================\r\n\r\n（[https://todo.microsoft.com/](https://todo.microsoft.com/)）\r\n\r\n互联网行业节奏向来很快，而我们身为一名互联网人，得把时间管理刻进骨子里，所以，给大家推荐一个我常用来进行时间管理的工具，Microsoft To Do。\r\n\r\nMicrosoft To Do默认的清单设置有“我的一天”、“重要”和“To do”三个清单分类，界面简洁清爽，很容易上手。\r\n\r\n而且Microsoft To Do完全免费，支持Windows、macOS、Android、iOS等多个平台，因此我们可以在任意设备上管理自己的任务，十分方便~\r\n\r\n到晚上时，看着清单上的一项项任务都被划掉，相当有成就感！\r\n\r\n![图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/14fc0883107e42d88780234115f7d54a~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n好了，以上就是本次的全部分享，吐血整理，希望大家点赞鼓励~\r\n\r\n评论区也给我推荐一波你们觉得好用的工具吧！\r\n\r\n  "
    },
    {   "snapshot": "https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/90ffab6417f743489311f5cc1c7c75ee~tplv-k3u1fbpfcp-watermark.image?",
        "title": "一个40岁老程序员的2022年中总结 - 四十不惑，不忘初心",
        "preview": "2022年对我来说是里程碑的一年，因为就在今年五月，我正式年满四十岁，成为了一名在某些贩卖焦虑的 IT 自媒体笔下的面临 \"年龄危机\" 的老程序员。",
        "author": "JerryWang_sap",
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/0e2d882d341c23df275c42768c0deefa~300x300.image",
        "content": "---\r\ntheme: channing-cyan\r\n---\r\n\r\n「时光不负，创作不停，本文正在参加[2022年中总结征文大赛](https://juejin.cn/post/7108989863126368286 \\\"https://juejin.cn/post/7108989863126368286\\\")」\r\n\r\n2022年对我来说是里程碑的一年，因为就在今年五月，我正式年满四十岁，成为了一名在某些贩卖焦虑的 IT 自媒体笔下的面临 `年龄危机` 的老程序员。\r\n\r\n一转眼，2022 年又快过去一半了。借着参加掘金社区`2022年中总结征文大赛`的机会，我把自己这过去的半年经历，简单做一个复盘。\r\n\r\n# 我上半年的日常工作和技术写作生活\r\n\r\n我于 2007 年 7 月，在电子科技大学计算机系统结构专业硕士毕业后，加入了 SAP 成都研究院，成了一名应用开发程序员。SAP 是一家总部位于德国的软件公司，主要从事企业管理软件领域的开发。十五年过去了，我也很光荣地拿到了 SAP 给工作超过十年以上的员工颁发的纪念奖杯，如下图所示：\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a75e4a48e2a84328afccafe3120c4971~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n我十五年的工作生涯，当然也不止一次思考过自己的职业规划和未来的职业发展方向。关于`国内`程序员 35 岁以后的出路，网络上已经有很多讨论了，不外乎以下几条：\r\n\r\n- 自己创业\r\n- 继续做一名程序员，成为技术专家\r\n- 转型成项目经理、产品经理、质量工程师、架构师等软件开发流程中的其他角色\r\n- 转行，离开程序开发行业\r\n\r\n对我来说，一件幸运的事情是，毕业之后尽管在同一家公司已经做了15年的软件开发，但如今的我对技术的热情，和我第一天正式入职相比，并没有减弱多少。所以我觉得，继续坚持在一线做开发，努力成为技术专家，是最贴合我实际情况的职场之路。\r\n\r\n到 2020 年之前，我从事的一直都是偏后端的开发，使用的是 ABAP，Java 和 Node.js 这些偏后端的编程语言和技术栈。2020年 8 月，由于工作变动，开始接触 Angular 和 TypeScript，工作方向也转移到了前端开发领域，一直做到现在。我现在的日常工作，是开发一款代号为 Spartacus 的 SAP 电商云前台 Storefront 应用：\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5253c38e723240018df362752608649a~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/03ff3989d81a4c58a04028ec55e4b83d~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n我还记得刚刚从后端转到前端时，由于十几年根深蒂固的后端开发思维，对前端开发的有些理念，尤其是对 Angular 框架里重度使用的响应式编程框架 RxJs 很不适应，也被后者陡峭的学习曲线(至少对于我来说很陡峭)折磨过。所幸我所在团队里有不少才华横溢的 Angular 开发工程师，并且乐于助人，在他们的帮助下，我逐渐找到了前端开发的一些感觉。而我之前一直用 ABAP 和 Java 开发后端，对于现在 Angular 里的装饰器、注解，依赖注入等概念也觉得非常亲切。\r\n\r\n2022 年年初到现在，使用 Angular 完成日常工作之余，我陆陆续续看完了两本 Angular 开发的纸质书，把 Angular 官网的教程和文档都过了一遍，最近在研读一本名叫《深入浅出 RxJs》的中文书。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff66f0da1c264f3aac981d0f738223b3~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n尽管很多 RxJs 高手可能觉得其官网的文档和 Demo 更权威更有帮助，我由于水平有限，还是更喜欢看这本国内专家用中文写的书，适合自己的才是最好的。\r\n\r\n笔者一直保持着通过技术博客将自己所学的知识输出的习惯，这些年在国内外各大技术社区也发表了一些技术文章。\r\n\r\n感谢掘金社区的支持，授予了我`优秀创作者`的称号：\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/18b3e9dac236459198c5941aec6cac11~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n我知道自己输出的前端开发的文章，从内容深度上来说，肯定不能和掘金社区上的前端大神相比，然而我也确实没有和人比较的念头，输出这些文章的初衷是记录自己工作中遇到的疑难点，同时希望能够帮助一些遇到和我同样问题的初学者们。我已经年满四十，早已过了爱争强好胜和人暗自较劲的年龄了，只要自己每天和前一天相比，都有点滴进步，我也就满足了。\r\n\r\n我今年也积极参加了掘金社区一些活动，下面是我获得的一些纪念品。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd37faef3af64490867cb1ffc440be94~tplv-k3u1fbpfcp-zoom-1.image)\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/10a9879958d94b4d8e62cc575e7f34c8~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n# 年满 40 岁之后对技术学习方式的一些思考\r\n\r\n今年上半年我也在不断思考，觉得自己将来技术学习的方式需要持续做出一些转变方法，记录如下。\r\n\r\n## 不再只拘泥于具体的源代码细节\r\n\r\n在我从25岁硕士毕业参加工作到35岁这期间，我觉得是一个程序员潜心钻研技术的黄金十年：精力充沛，业余时间多，学习能力强。在我过去的十年里，我觉得我对待技术的态度上有点像强迫症患者，对于一个技术点，除了了解它的设计原理和架构之外，我还喜欢从源代码的层级去研究。我毕业后加入 SAP 从事的头几个产品开发，都是基于 ABAP 技术栈的，产品的每一行源代码对于开发者来说都可见。这极大地满足了我对这些产品实现源码的好奇心，让我一头扎进了代码的汪洋大海，也养成了我遇到问题就喜欢从源代码层级分析的习惯。\r\n\r\n随着我工作内容的变化，从相对比较封闭的 ABAP 技术栈，切换到了更加开放，甚至拥抱开源的技术领域，比如云原生开发，CloudFoundry，Docker，Kubernetes，Node.js，Angular 等技术上来，我逐渐发现自己过去那种基于源代码级别的学习方式已经不再是一种有效或者说现实的方法了，原因有二：\r\n\r\n1. 程序员年满35岁，成家立业，结婚生子之后，客观上不太可能再有像以前单身时那样，有大块大块的空闲时间能静下心来研读源码。人到中年，上有老，下有小，程序员的业余时间太容易被生活中其他事情所占据了。\r\n\r\n2. 当今的开源产品或者说工具库，其实现复杂度和代码量，已经远远超过了某一个程序员能够掌握的范畴了。即便是某个开源项目的贡献者本身，他/她们熟悉的也只是自己共享的那一个模块的部分代码。 \r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f08617fa6b544e97938681c2623070ed~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n以 Kubernetes 的使用为例，遇到错误消息时，按照我过去的做法，我会尝试根据错误消息的文本，去搜索 Kubernetes Github 上的源代码，找到哪些源代码里有可能会抛出这个错误消息。现在我觉得更有效的方法，当然是 Google 或者 StackOverflow 上搜索线索，因为这么流行的技术平台，我们遇到的问题，大概率早就有其他同行遇到过了，网友们的分析和解决方案，对我们的问题排查来说有极大的借鉴意义。\r\n\r\n同样，在学习一个新技术 & 框架时，放在过去，我会先把它的 quick start / demo / tutorial 找到，尽快在自己本地搭一个环境，弄一个可以运行的例子出来，然后再从源代码层面开始学习。现在的我会老老实实从这些新技术的官网的 Overview 页面开始读起，了解这个新技术诞生的缘由，解决了什么业务痛点，主要的组成模块，设计架构等等。我觉得一个40岁的程序员，和30岁的程序员，20岁的程序员，对同一项技术的关注点理应有所不同。20岁的程序员，关注的更多的是技术的具体实现细节和使用方式。40岁的程序员，更多应该关注的技术背后的一些深层次东西，比如这些技术，如何才能更好地融入到自己公司所负责的业务和产品中去，如何才能给客户带来更多的价值？\r\n\r\n更现实一点的问题就是，我现在40岁，在这家公司工作了15年，我和公司现在刚入职的25岁年轻程序员相比，我作为一个老程序员，我的价值和核心竞争力到底体现在哪些地方？这个问题也是我工作过程中一直在思考的问题。\r\n\r\n## 学会取舍，学会做减法\r\n\r\n在我刚刚成为一名年轻的程序员时，我曾经误以为，一个程序员会使用的编程语言、编程工具越多，运用的技术越流行，掌握的技术栈越熟练，这个程序员就越优秀。在这种想法的驱动下，我尽可能多地去尝试新的编程技术和工具，不管这些东西在自己工作中是否能应用得上。每天泡各种技术论坛，一看到介绍新鲜技术和工具的帖子，马上在自己本机上尝试。坚持了一段时间之后我发觉，即便这样做，也没有成为自己心目中“优秀的程序员”的样子。反而因为很多新技术只是浅尝辄止，在工作中没有运用上，成了屠龙之技，所以一段时间过后就遗忘得差不多了。\r\n\r\n因为笔者工作的 SAP 业务是开发企业管理软件，所以在工作一段时间深受这家德国企业的文化熏陶之后，我也慢慢领悟到，即便一项技术再先进和流行，如果它不能帮助公司的客户解决其业务上的痛点，无法给客户带来实际的价值，无法帮助自己在职场进阶之路上走得更顺畅，那么我在下决定业余时间去学习它之前，就应该慎之又慎，因为大龄程序员的业余时间实在太宝贵了。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d338670c4f524b37bc9e911b5599866d~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n因此我这一章节副标题的学会取舍和做减法，就是想提醒自己，在新的开发技术和开发理念不断涌现的大环境下，大龄程序员对于分配自己业余时间用于技术充电这一点上，一定要慎之又慎。好钢用在刀刃上，优先投资那些能给自己的职业发展和公司业务带来助力的技术上。\r\n\r\n以上自言自语了这么长的篇幅，感谢大家耐心看完一个40岁中年男人的碎碎念。笔者希望自己能够不忘22年前高考填志愿选择计算机专业时的初心，希望自己能够在迈入四十岁大关之后，能真正做到四十不惑。笔者也祝愿各位程序员同行，在 2022年下半年里能够工作顺利，技术上更上一层楼，感谢阅读。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/08ea1f033dda4e2ba3280391d02a8d09~tplv-k3u1fbpfcp-zoom-1.image)\r\n"
    },
    {   "snapshot": "",
        "title": "短短1个小时，让公司损失近3万",
        "preview": "这是一个悲伤的故事，也是教训最深刻的一次。发生在2022年1月份，春节前几周。在聊这个事之前，我想借用美团的一个案例作为切入点。 （我们公司不是美团的这种业务，但也利用了会员发券这种机制，都是在待支付",
        "author": "苏世_",
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/7be56cc0c7c89d14005ec33559fa75cf~300x300.image",
        "content": "---\r\ntheme: channing-cyan\r\n---\r\n\r\n「时光不负，创作不停，本文正在参加[2022年中总结征文大赛](https://juejin.cn/post/7108989863126368286)\r\n\r\n这是一个悲伤的故事，也是教训最深刻的一次。发生在2022年1月份，春节前几周。在聊这个事之前，我想借用美团的一个案例作为切入点。 \r\n\r\n（我们公司不是美团的这种业务，但也利用了会员发券这种机制，都是在待支付勾选会员产生待使用的券，最后选择使用，这里我就拿美团来讲）\r\n\r\n\r\n先来看下面这幅图，大家点外卖再熟悉不过的一个页面！\r\n\r\n\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7d1b3e01aeb24608bda8ebc0b4ba8202~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n\r\n当勾选开通会员时，系统会自动给你发6张优惠券（取消勾选，则6张券消失）\r\n\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d9dcc053978b4f9da13a644a6f65c455~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n那么问题来了，这6张券是怎样的一种方式存在？\r\n\r\n> 因为这里要考虑到，用户勾选只是勾选，还没有真正的发到用户钱包里，只有用户支付了，才能真正给用户发送，这里面就牵扯到这个临时数据怎么处理更好\r\n\r\n我想了想，无非三种\r\n    \r\n   - 前端自己生成数据，给后端规约传参\r\n   - 后台落noSql，用户在选择券的时候，后台查询优惠券接口会把noSql里的东西也带上\r\n   - 后台存关系型数据库，这里就会牵扯到太多的垃圾数据，因为很多用户可能只是勾选，并不会购买\r\n   \r\n   \r\n   大的方面应该就这三种，至于细节，那各凭本事，看谁处理的好。\r\n   \r\n   \r\n## 最难的需求\r\n\r\n时间拉回到今年1月份，这是春节前最悠哉的时光，年终奖都定好了！\r\n\r\n\r\n忽然开会说要在待支付界面引入会员机制，周期为一周，快速上线，要先看数据。根据数据节后再做调整。没给开发留一点点评估的时间，还没容得上我们说话，就。。。。\r\n\r\n\r\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1e66bc4999bc497c98a5f79b9e75cbd9~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n这里简单说下需求吧：\r\n\r\n**平台会员原来就有，只是没有介入到待支付，原来购买平台会员发两张券，这次到待支付要根据用户不同的属性发送不同的券，张数也不尽相同**\r\n\r\n\r\n作为产品部的技术负责人，在这个周期范围内，首要做的就是看如何快速上线，我和产品商量砍了很多需求，原型设计上的很多细节都包括在内，否则干死都不一定能上线（天下产品都一样，研发不硬，产品必欺。但这次是运营是拿着尚方宝剑给产品下的命令，时间既然是不能变的，那就只能把需求点减到最少）\r\n\r\n\r\n\r\n\r\n就这样，技术方案用了最简单的，也是最不安全的，没错，全部交给前端去生成券的数据。金额都是写死的，说白了，就是前端按照ui图出的，后台没有出接口，因为在整体支付流程还有大量工作需要因为平台会员的介入而有大量工作（别说不专业，没办法）。\r\n\r\n\r\n\r\n所以，减免多少钱，是由前端传的（这里可能很多人会笑话我，因为没有一家是前端传金额的，是的，我们做了）\r\n\r\n\r\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4ef6aca2f24c4073bd613d6a31b04e3a~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n\r\n看到这里肯定有人说，虽然不合理，但是应该也不会有大问题啊。\r\n\r\n\r\n可是问题就是爆发出来了。我们有一种券，叫”全免券“，就可以免掉本次费用。前端因为很多数据写死了，结果这个全免券没有考虑进去。测试当时测试的时候也忽略了，导致线上在某种情况下会走全免券的机制\r\n\r\n\r\n\r\n## 黑色星期五\r\n\r\n我们任何上线的时间都会定到周四晚上，因为周四升级，周五如果有问题，可以处理回退。\r\n\r\n\r\n清晨睡的正香，电话响了，一看群里，炸锅了。我们的用户端主要是微信小程序，了解的都知道有个审核期，后台服务晚上升级好之后，小程序是早上运维给审核通过的。\r\n\r\n\r\n结果运营早上看到很多数据，好多用户支付都是0元，对比一看全都购买过平台会员。顿时我就没有了睡意，赶紧通知运维把小程序回退到上一个版本（幸亏后台接口兼容处理得当）\r\n\r\n\r\n*问题就是A类用户在B种情况下，传到后台就是走全免券的逻辑。*\r\n\r\n顿时“精神抖擞”的我收拾收拾背包去公司了\r\n\r\n\r\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/46e14b5b4d644c68981cda37e38e72eb~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n\r\n\r\n最后好像运营给出一个数据，3万左右。我私下里也大概算了下。。。。。。\r\n\r\n年终奖整个team都削了点，包括我们部分老大，包括测试。主要责任在我，方案是我定的，确实不是最佳选择。\r\n\r\n## 总结教训\r\n\r\n\r\n这确实是我入行以来最大的bug，作为负责人没有处理好可能出现的问题，从方案到落地，需要慎之又慎。\r\n\r\n\r\n协调各部门，统筹方案。 \r\n\r\n\r\n也给产品和运营个教训吧。就说到这里吧，希望给大家点经验，祝大家写不出八阿哥\r\n"
    }
]